/**
 * Copyright (c) 2018-2022, BOTLabs GmbH.
 *
 * This source code is licensed under the BSD 4-Clause "Original" license
 * found in the LICENSE file in the root directory of this source tree.
 */
/// <reference types="node" />
/**
 * Crypto provides KILT with the utility types and methods useful for cryptographic operations, such as signing/verifying, encrypting/decrypting and hashing.
 *
 * The utility types and methods are wrappers for existing Polkadot functions and imported throughout KILT's protocol for various cryptographic needs.
 *
 * @packageDocumentation
 */
import { decodeAddress, encodeAddress } from '@polkadot/keyring';
import type { KiltEncryptionKeypair, KeyringPair, KiltKeyringPair } from '@kiltprotocol/types';
import { u8aConcat, u8aToHex } from '@polkadot/util';
import type { HexString } from '@polkadot/util/types';
export { naclBoxPairFromSecret, mnemonicGenerate, mnemonicToMiniSecret, } from '@polkadot/util-crypto';
export { encodeAddress, decodeAddress, u8aToHex, u8aConcat };
/**
 * Types accepted by hashing and crypto functions.
 */
export declare type CryptoInput = Buffer | Uint8Array | string;
export declare type Address = string;
export declare type EncryptedAsymmetric = {
    box: Uint8Array;
    nonce: Uint8Array;
};
export declare type EncryptedAsymmetricString = {
    box: string;
    nonce: string;
};
/**
 * Creates a Uint8Array value from a Uint8Array, Buffer, string or hex input.
 *
 * @param input Input array or string. Null or undefined result in an empty array.
 * @param hexAsString Whether or not a hex string is encoded as a string instead of a number.
 * @returns A (possibly empty) Uint8Array.
 */
export declare function coToUInt8(input: CryptoInput | null | undefined, hexAsString?: boolean): Uint8Array;
/**
 * Signs a message.
 *
 * @param message String or byte array to be signed.
 * @param signKeyPair KeyringPair used for signing.
 * @returns Signature over message as byte array.
 */
export declare function sign(message: CryptoInput, signKeyPair: KeyringPair): Uint8Array;
/**
 * Signs a message. Returns signature string.
 *
 * @param message String or byte array to be signed.
 * @param signKeyPair KeyringPair used for signing.
 * @returns Signature over message as hex string.
 */
export declare function signStr(message: CryptoInput, signKeyPair: KeyringPair): string;
/**
 * Verifies a signature over a message.
 *
 * @param message Original signed message to be verified.
 * @param signature Signature as hex string or byte array.
 * @param addressOrPublicKey Substrate address or public key of the signer.
 */
export declare function verify(message: CryptoInput, signature: CryptoInput, addressOrPublicKey: Address | HexString | Uint8Array): void;
export declare type BitLength = 64 | 128 | 256 | 384 | 512;
/**
 * Create the blake2b and return the result as an u8a with the specified `bitLength`.
 *
 * @param value Value to be hashed.
 * @param bitLength Bit length of hash.
 * @returns Blake2b hash byte array.
 */
export declare function hash(value: CryptoInput, bitLength?: BitLength): Uint8Array;
/**
 * Create the blake2b and return the result as a hex string.
 *
 * @param value Value to be hashed.
 * @returns Blake2b hash as hex string.
 */
export declare function hashStr(value: CryptoInput): HexString;
/**
 * Stringifies numbers, booleans, and objects. Object keys are sorted to yield consistent hashing.
 *
 * @param value Object or value to be hashed.
 * @returns Stringified representation of the given object.
 */
export declare function encodeObjectAsStr(value: Record<string, any> | string | number | boolean): string;
/**
 * Wrapper around nacl.box. Authenticated encryption of a message for a recipient's public key.
 *
 * @param message String or byte array to be encrypted.
 * @param publicKeyA Public key of the recipient. The owner will be able to decrypt the message.
 * @param secretKeyB Private key of the sender. Necessary to authenticate the message during decryption.
 * @returns Encrypted message and nonce used for encryption.
 */
export declare function encryptAsymmetric(message: CryptoInput, publicKeyA: CryptoInput, secretKeyB: CryptoInput): EncryptedAsymmetric;
/**
 * Wrapper around nacl.box. Authenticated encryption of a message for a recipient's public key.
 *
 * @param message String or byte array to be encrypted.
 * @param publicKeyA Public key of the recipient. The owner will be able to decrypt the message.
 * @param secretKeyB Private key of the sender. Necessary to authenticate the message during decryption.
 * @returns Encrypted message and nonce used for encryption as hex strings.
 */
export declare function encryptAsymmetricAsStr(message: CryptoInput, publicKeyA: CryptoInput, secretKeyB: CryptoInput): EncryptedAsymmetricString;
/**
 * Wrapper around nacl.box.open. Authenticated decryption of an encrypted message.
 *
 * @param data Object containing encrypted message and nonce used for encryption.
 * @param publicKeyB Public key of the sender. Necessary to authenticate the message during decryption.
 * @param secretKeyA Private key of the recipient. Required for decryption.
 * @returns Decrypted message or false if decryption is unsuccessful.
 */
export declare function decryptAsymmetric(data: EncryptedAsymmetric | EncryptedAsymmetricString, publicKeyB: CryptoInput, secretKeyA: CryptoInput): Uint8Array | false;
/**
 * Wrapper around nacl.box.open. Authenticated decryption of an encrypted message.
 *
 * @param data Object containing encrypted message and nonce used for encryption.
 * @param publicKeyB Public key of the sender. Necessary to authenticate the message during decryption.
 * @param secretKeyA Private key of the recipient. Required for decryption.
 * @returns Decrypted message as string or false if decryption is unsuccessful.
 */
export declare function decryptAsymmetricAsStr(data: EncryptedAsymmetric | EncryptedAsymmetricString, publicKeyB: CryptoInput, secretKeyA: CryptoInput): string | false;
/**
 * Signature of hashing function accepted by [[hashStatements]].
 *
 * @param value String to be hashed.
 * @param nonce Optional nonce (as string) used to obscure hashed contents.
 * @returns String representation of hash.
 */
export interface Hasher {
    (value: string, nonce?: string): HexString;
}
/**
 * Additional options for [[hashStatements]].
 */
export interface HashingOptions {
    nonces?: Record<string, string>;
    nonceGenerator?: (key: string) => string;
    hasher?: Hasher;
}
/**
 * Default hasher for [[hashStatements]].
 *
 * @param value String to be hashed.
 * @param nonce Optional nonce (as string) used to obscure hashed contents.
 * @returns 256 bit blake2 hash as hex string.
 */
export declare function saltedBlake2b256(value: string, nonce?: string): HexString;
/**
 * Configurable computation of salted over an array of statements. Can be used to validate/reproduce salted hashes
 * by means of an optional nonce map.
 *
 * @param statements An array of statement strings to be hashed.
 * @param options Optional hasher arguments.
 * @param options.nonces An optional map or array of nonces. If present, it should comprise all keys of `statements`, as those will be used map nonces to statements.
 * @param options.nonceGenerator An optional nonce generator. Will be used if `options.nonces` is not defined to generate a (new) nonce for each statement. The statement key is passed as its first argument. If no `nonces` or `nonceGenerator` are given this function returns unsalted hashes.
 * @param options.hasher The hasher to be used. Computes a hash from a statement and an optional nonce. Required but defaults to 256 bit blake2 over `${nonce}${statement}`.
 * @returns An array of objects for each statement which contain a statement, its digest, salted hash and nonce.
 */
export declare function hashStatements(statements: string[], options?: HashingOptions): Array<{
    digest: HexString;
    statement: string;
    saltedHash: HexString;
    nonce: string;
}>;
/**
 * Generate typed KILT blockchain keypair from a seed or random data.
 *
 * @param seed The keypair seed, only optional in the tests.
 * @param type Optional type of the keypair.
 * @returns The keypair.
 */
export declare function makeKeypairFromSeed<KeyType extends KiltKeyringPair['type'] = 'ed25519'>(seed?: Uint8Array, type?: KeyType): KiltKeyringPair & {
    type: KeyType;
};
/**
 * Generate typed KILT blockchain keypair from a polkadot keypair URI.
 *
 * @param uri The URI.
 * @param type Optional type of the keypair.
 * @returns The keypair.
 */
export declare function makeKeypairFromUri<KeyType extends KiltKeyringPair['type'] = 'ed25519'>(uri: string, type?: KeyType): KiltKeyringPair & {
    type: KeyType;
};
/**
 * Generate from a seed a x25519 keypair to be used as DID encryption key.
 *
 * @param seed The keypair seed, only optional in the tests.
 * @returns The keypair.
 */
export declare function makeEncryptionKeypairFromSeed(seed?: Uint8Array): KiltEncryptionKeypair;
