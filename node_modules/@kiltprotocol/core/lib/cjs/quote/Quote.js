"use strict";
/**
 * Copyright (c) 2018-2022, BOTLabs GmbH.
 *
 * This source code is licensed under the BSD 4-Clause "Original" license
 * found in the LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyQuoteAgreement = exports.createQuoteAgreement = exports.verifyAttesterSignedQuote = exports.createAttesterSignedQuote = exports.validateQuoteSchema = void 0;
const utils_1 = require("@kiltprotocol/utils");
const did_1 = require("@kiltprotocol/did");
const QuoteSchema_js_1 = require("./QuoteSchema.js");
/**
 * Validates the quote against the meta schema and quote data against the provided schema.
 *
 * @param schema A [[Quote]] schema object.
 * @param validate [[Quote]] data to be validated against the provided schema.
 * @param messages The errors messages are listed in an array.
 *
 * @returns Whether the quote schema is valid.
 */
function validateQuoteSchema(schema, validate, messages) {
    const validator = new utils_1.JsonSchema.Validator(schema);
    if (schema.$id !== QuoteSchema_js_1.QuoteSchema.$id) {
        validator.addSchema(QuoteSchema_js_1.QuoteSchema);
    }
    const result = validator.validate(validate);
    if (!result.valid && messages) {
        result.errors.forEach((error) => {
            messages.push(error.error);
        });
    }
    return result.valid;
}
exports.validateQuoteSchema = validateQuoteSchema;
// TODO: should have a "create quote" function.
/**
 * Signs a [[Quote]] object as an Attester.
 *
 * @param quoteInput A [[Quote]] object.
 * @param sign The callback to sign with the private key.
 * @returns A signed [[Quote]] object.
 */
async function createAttesterSignedQuote(quoteInput, sign) {
    if (!validateQuoteSchema(QuoteSchema_js_1.QuoteSchema, quoteInput)) {
        throw new utils_1.SDKErrors.QuoteUnverifiableError();
    }
    const signature = await sign({
        data: utils_1.Crypto.hash(utils_1.Crypto.encodeObjectAsStr(quoteInput)),
        did: quoteInput.attesterDid,
        keyRelationship: 'authentication',
    });
    return {
        ...quoteInput,
        attesterSignature: (0, did_1.signatureToJson)(signature),
    };
}
exports.createAttesterSignedQuote = createAttesterSignedQuote;
/**
 * Verifies a [[IQuoteAttesterSigned]] object.
 *
 * @param quote The object which to be verified.
 * @param options Optional settings.
 * @param options.didResolveKey Resolve function used in the process of verifying the attester signature.
 */
async function verifyAttesterSignedQuote(quote, { didResolveKey = did_1.resolveKey, } = {}) {
    const { attesterSignature, ...basicQuote } = quote;
    await (0, did_1.verifyDidSignature)({
        ...(0, did_1.signatureFromJson)(attesterSignature),
        message: utils_1.Crypto.hashStr(utils_1.Crypto.encodeObjectAsStr(basicQuote)),
        expectedSigner: basicQuote.attesterDid,
        expectedVerificationMethod: 'authentication',
        didResolveKey,
    });
    const messages = [];
    if (!validateQuoteSchema(QuoteSchema_js_1.QuoteSchema, basicQuote, messages)) {
        throw new utils_1.SDKErrors.QuoteUnverifiableError();
    }
}
exports.verifyAttesterSignedQuote = verifyAttesterSignedQuote;
/**
 * Creates a [[Quote]] signed by the Attester and the Claimer.
 *
 * @param attesterSignedQuote A [[Quote]] object signed by an Attester.
 * @param credentialRootHash A root hash of the entire object.
 * @param sign The callback to sign with the private key.
 * @param claimerDid The DID of the Claimer, who has to sign.
 * @param options Optional settings.
 * @param options.didResolveKey Resolve function used in the process of verifying the attester signature.
 * @returns A [[Quote]] agreement signed by both the Attester and Claimer.
 */
async function createQuoteAgreement(attesterSignedQuote, credentialRootHash, sign, claimerDid, { didResolveKey = did_1.resolveKey, } = {}) {
    const { attesterSignature, ...basicQuote } = attesterSignedQuote;
    await (0, did_1.verifyDidSignature)({
        ...(0, did_1.signatureFromJson)(attesterSignature),
        message: utils_1.Crypto.hashStr(utils_1.Crypto.encodeObjectAsStr(basicQuote)),
        expectedVerificationMethod: 'authentication',
        didResolveKey,
    });
    const quoteAgreement = {
        ...attesterSignedQuote,
        rootHash: credentialRootHash,
        claimerDid,
    };
    const signature = await sign({
        data: utils_1.Crypto.hash(utils_1.Crypto.encodeObjectAsStr(quoteAgreement)),
        did: claimerDid,
        keyRelationship: 'authentication',
    });
    return {
        ...quoteAgreement,
        claimerSignature: (0, did_1.signatureToJson)(signature),
    };
}
exports.createQuoteAgreement = createQuoteAgreement;
/**
 * Verifies a [[IQuoteAgreement]] object.
 *
 * @param quote The object to be verified.
 * @param options Optional settings.
 * @param options.didResolveKey Resolve function used in the process of verifying the attester signature.
 */
async function verifyQuoteAgreement(quote, { didResolveKey = did_1.resolveKey, } = {}) {
    const { claimerSignature, claimerDid, rootHash, ...attesterSignedQuote } = quote;
    // verify attester signature
    await verifyAttesterSignedQuote(attesterSignedQuote, { didResolveKey });
    // verify claimer signature
    await (0, did_1.verifyDidSignature)({
        ...(0, did_1.signatureFromJson)(claimerSignature),
        message: utils_1.Crypto.hashStr(utils_1.Crypto.encodeObjectAsStr({ ...attesterSignedQuote, claimerDid, rootHash })),
        expectedSigner: claimerDid,
        expectedVerificationMethod: 'authentication',
        didResolveKey,
    });
}
exports.verifyQuoteAgreement = verifyQuoteAgreement;
