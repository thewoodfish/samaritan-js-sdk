"use strict";
/**
 * Copyright (c) 2018-2022, BOTLabs GmbH.
 *
 * This source code is licensed under the BSD 4-Clause "Original" license
 * found in the LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAttestationHashes = exports.getChildren = exports.fetch = exports.addDelegationToChainArgs = void 0;
const tslib_1 = require("tslib");
const config_1 = require("@kiltprotocol/config");
const utils_1 = require("@kiltprotocol/utils");
const Did = tslib_1.__importStar(require("@kiltprotocol/did"));
const DelegationDecoder_js_1 = require("./DelegationDecoder.js");
const DelegationNode_js_1 = require("./DelegationNode.js");
const DelegationNode_utils_js_1 = require("./DelegationNode.utils.js");
const log = config_1.ConfigService.LoggingFactory.getLogger('DelegationNode');
/**
 * Encodes the delegation and the signature for usage as arguments of `api.tx.delegation.addDelegation()`.
 *
 * @param delegation The delegation node to store under the hierarchy specified as part of the node.
 * @param signature The DID signature of the delegate owner of the new delegation node.
 * @returns The array of arguments for `addDelegation`.
 */
function addDelegationToChainArgs(delegation, signature) {
    return [
        delegation.id,
        delegation.parentId || '',
        Did.toChain(delegation.account),
        (0, DelegationNode_utils_js_1.permissionsAsBitset)(delegation),
        signature,
    ];
}
exports.addDelegationToChainArgs = addDelegationToChainArgs;
/**
 * Fetch a delegation node from the blockchain given its identifier.
 *
 * @param delegationId The delegation node ID to fetch.
 * @returns The retrieved [[DelegationNode]].
 */
async function fetch(delegationId) {
    const api = config_1.ConfigService.get('api');
    const chainNode = await api.query.delegation.delegationNodes(delegationId);
    if (chainNode.isNone) {
        throw new utils_1.SDKErrors.DelegationIdMissingError();
    }
    return new DelegationNode_js_1.DelegationNode({
        ...(0, DelegationDecoder_js_1.delegationNodeFromChain)(chainNode),
        id: delegationId,
    });
}
exports.fetch = fetch;
/**
 * Query the blockchain to retrieve the number of **direct** children of a given delegation node.
 *
 * @param delegationNode The delegation node to perform the lookup for.
 * @returns A list of [[DelegationNode]] containing all the direct children of the provided node.
 */
async function getChildren(delegationNode) {
    log.info(` :: getChildren('${delegationNode.id}')`);
    const childrenNodes = await Promise.all(delegationNode.childrenIds.map(fetch));
    log.info(`children: ${JSON.stringify(childrenNodes)}`);
    return childrenNodes;
}
exports.getChildren = getChildren;
/**
 * Query the blockchain to retrieve all the attestations (their claim hashes) created with the provided delegation.
 *
 * @param id The identifier of the delegation node to retrieve delegated attestations for.
 * @returns A list of claim hashes issued using the provided delegation.
 */
async function getAttestationHashes(id) {
    const api = config_1.ConfigService.get('api');
    // this info is stored chain-side as a double map from (authorizationId, claimHash) -> boolean.
    // the following line retrieves all keys where authorizationId is equal to the delegation id.
    const entries = await api.query.attestation.externalAttestations.keys({
        Delegation: id,
    });
    // extract claimHash from double map key & decode
    return entries.map((keys) => keys.args[1].toHex());
}
exports.getAttestationHashes = getAttestationHashes;
