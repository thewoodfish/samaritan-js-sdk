/**
 * Copyright (c) 2018-2022, BOTLabs GmbH.
 *
 * This source code is licensed under the BSD 4-Clause "Original" license
 * found in the LICENSE file in the root directory of this source tree.
 */
import { Permission } from '@kiltprotocol/types';
import * as Did from '@kiltprotocol/did';
export function delegationHierarchyDetailsFromChain(encoded) {
    return {
        cTypeHash: encoded.unwrap().ctypeHash.toHex(),
    };
}
/**
 * Decode the permissions from the bitset encoded in the given `number`.
 * We use bitwise `AND` to check if a permission bit flag is set.
 *
 * @param encoded The u32 number used as the bitset to encode permissions.
 * @returns The permission set.
 */
function permissionsFromChain(encoded) {
    const bitset = encoded.bits.toNumber();
    const permissions = [];
    // eslint-disable-next-line no-bitwise
    if ((bitset & Permission.ATTEST) > 0) {
        permissions.push(Permission.ATTEST);
    }
    // eslint-disable-next-line no-bitwise
    if ((bitset & Permission.DELEGATE) > 0) {
        permissions.push(Permission.DELEGATE);
    }
    return permissions;
}
export function delegationNodeFromChain(encoded) {
    const delegationNode = encoded.unwrap();
    return {
        hierarchyId: delegationNode.hierarchyRootId.toHex(),
        parentId: delegationNode.parent.isSome
            ? delegationNode.parent.toHex()
            : undefined,
        childrenIds: [...delegationNode.children].map((id) => id.toHex()),
        account: Did.fromChain(delegationNode.details.owner),
        permissions: permissionsFromChain(delegationNode.details.permissions),
        revoked: delegationNode.details.revoked.valueOf(),
    };
}
