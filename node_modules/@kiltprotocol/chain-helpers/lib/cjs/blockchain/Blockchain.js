"use strict";
/**
 * Copyright (c) 2018-2022, BOTLabs GmbH.
 *
 * This source code is licensed under the BSD 4-Clause "Original" license
 * found in the LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.signAndSubmitTx = exports.dispatchTx = exports.submitSignedTx = exports.EXTRINSIC_FAILED = exports.IS_ERROR = exports.IS_FINALIZED = exports.EXTRINSIC_EXECUTED = exports.IS_IN_BLOCK = exports.IS_READY = exports.TxDuplicate = exports.TxPriority = exports.TxOutdated = void 0;
const api_1 = require("@polkadot/api");
const config_1 = require("@kiltprotocol/config");
const utils_1 = require("@kiltprotocol/utils");
const index_js_1 = require("../errorhandling/index.js");
const SubscriptionPromise_js_1 = require("./SubscriptionPromise.js");
const log = config_1.ConfigService.LoggingFactory.getLogger('Blockchain');
exports.TxOutdated = 'Transaction is outdated';
exports.TxPriority = 'Priority is too low:';
exports.TxDuplicate = 'Transaction Already Imported';
/**
 * Evaluator resolves on extrinsic reaching status "is ready".
 *
 * @param result Submission result.
 * @returns Whether the extrinsic reached status "is ready".
 */
function IS_READY(result) {
    return result.status.isReady;
}
exports.IS_READY = IS_READY;
/**
 * Evaluator resolves on extrinsic reaching status "in block".
 *
 * @param result Submission result.
 * @returns Whether the extrinsic reached status "in block".
 */
function IS_IN_BLOCK(result) {
    return result.isInBlock;
}
exports.IS_IN_BLOCK = IS_IN_BLOCK;
/**
 * Evaluator resolves on extrinsic reaching status "success".
 *
 * @param result Submission result.
 * @returns Whether the extrinsic reached status "success".
 */
function EXTRINSIC_EXECUTED(result) {
    return index_js_1.ErrorHandler.extrinsicSuccessful(result);
}
exports.EXTRINSIC_EXECUTED = EXTRINSIC_EXECUTED;
/**
 * Evaluator resolves on extrinsic reaching status "finalized".
 *
 * @param result Submission result.
 * @returns Whether the extrinsic reached status "finalized".
 */
function IS_FINALIZED(result) {
    return result.isFinalized;
}
exports.IS_FINALIZED = IS_FINALIZED;
/**
 * Evaluator resolves on extrinsic reaching status "is error".
 *
 * @param result Submission result.
 * @returns Whether the extrinsic reached status "is error" and the error itself.
 */
function IS_ERROR(result) {
    return result.isError || result.internalError;
}
exports.IS_ERROR = IS_ERROR;
/**
 * Evaluator resolves on extrinsic reaching status "is ready".
 *
 * @param result Submission result.
 * @returns Whether the extrinsic reached status "is ready".
 */
function EXTRINSIC_FAILED(result) {
    return index_js_1.ErrorHandler.extrinsicFailed(result);
}
exports.EXTRINSIC_FAILED = EXTRINSIC_FAILED;
function defaultResolveOn() {
    return config_1.ConfigService.isSet('submitTxResolveOn')
        ? config_1.ConfigService.get('submitTxResolveOn')
        : IS_FINALIZED;
}
/**
 * Submits a signed SubmittableExtrinsic and attaches a callback to monitor the inclusion status of the transaction
 * and possible errors in the execution of extrinsics. Returns a promise to that end which by default resolves upon
 * finalization or rejects if any errors occur during submission or execution of extrinsics. This behavior can be adjusted via optional parameters or via the [[ConfigService]].
 *
 * Transaction fees will apply whenever a transaction fee makes it into a block, even if extrinsics fail to execute correctly!
 *
 * @param tx The SubmittableExtrinsic to be submitted. Most transactions need to be signed, this must be done beforehand.
 * @param opts Allows overwriting criteria for resolving/rejecting the transaction result subscription promise. These options take precedent over configuration via the ConfigService.
 * @returns A promise which can be used to track transaction status.
 * If resolved, this promise returns ISubmittableResult that has led to its resolution.
 */
async function submitSignedTx(tx, opts = {}) {
    const { resolveOn = defaultResolveOn(), rejectOn = (result) => EXTRINSIC_FAILED(result) || IS_ERROR(result), } = opts;
    const api = config_1.ConfigService.get('api');
    if (!api.hasSubscriptions) {
        throw new utils_1.SDKErrors.SubscriptionsNotSupportedError();
    }
    log.info(`Submitting ${tx.method}`);
    const { promise, subscription } = (0, SubscriptionPromise_js_1.makeSubscriptionPromise)({
        ...opts,
        resolveOn,
        rejectOn,
    });
    let latestResult;
    const unsubscribe = await tx.send((result) => {
        latestResult = result;
        subscription(result);
    });
    function handleDisconnect() {
        const result = new api_1.SubmittableResult({
            events: latestResult?.events || [],
            internalError: new Error('connection error'),
            status: latestResult?.status ||
                api.registry.createType('ExtrinsicStatus', 'future'),
            txHash: api.registry.createType('Hash'),
        });
        subscription(result);
    }
    api.once('disconnected', handleDisconnect);
    try {
        return await promise;
    }
    catch (e) {
        throw index_js_1.ErrorHandler.getExtrinsicError(e) || e;
    }
    finally {
        unsubscribe();
        api.off('disconnected', handleDisconnect);
    }
}
exports.submitSignedTx = submitSignedTx;
exports.dispatchTx = submitSignedTx;
/**
 * Signs and submits the SubmittableExtrinsic with optional resolution and rejection criteria.
 *
 * @param tx The generated unsigned SubmittableExtrinsic to submit.
 * @param signer The [[KiltKeyringPair]] used to sign the tx.
 * @param opts Partial optional criteria for resolving/rejecting the promise.
 * @param opts.tip Optional amount of Femto-KILT to tip the validator.
 * @returns Promise result of executing the extrinsic, of type ISubmittableResult.
 */
async function signAndSubmitTx(tx, signer, { tip, ...opts } = {}) {
    const signedTx = await tx.signAsync(signer, { tip });
    return submitSignedTx(signedTx, opts);
}
exports.signAndSubmitTx = signAndSubmitTx;
