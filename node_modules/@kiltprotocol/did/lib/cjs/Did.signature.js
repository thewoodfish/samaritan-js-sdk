"use strict";
/**
 * Copyright (c) 2018-2022, BOTLabs GmbH.
 *
 * This source code is licensed under the BSD 4-Clause "Original" license
 * found in the LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.signatureFromJson = exports.signatureToJson = exports.isDidSignature = exports.verifyDidSignature = void 0;
const util_1 = require("@polkadot/util");
const utils_1 = require("@kiltprotocol/utils");
const index_js_1 = require("./DidResolver/index.js");
const Did_utils_js_1 = require("./Did.utils.js");
/**
 * Checks whether the input is a valid DidSignature object, consisting of a signature as hex and the uri of the signing key.
 * Does not cryptographically verify the signature itself!
 *
 * @param input Arbitrary input.
 */
function verifyDidSignatureDataStructure(input) {
    const keyUri = 'keyUri' in input ? input.keyUri : input.keyId;
    if (!(0, util_1.isHex)(input.signature)) {
        throw new utils_1.SDKErrors.SignatureMalformedError(`Expected signature as a hex string, got ${input.signature}`);
    }
    (0, Did_utils_js_1.validateUri)(keyUri, 'ResourceUri');
}
/**
 * Verify a DID signature given the key URI of the signature.
 * A signature verification returns false if a migrated and then deleted DID is used.
 *
 * @param input Object wrapping all input.
 * @param input.message The message that was signed.
 * @param input.signature Signature bytes.
 * @param input.keyUri DID URI of the key used for signing.
 * @param input.expectedSigner If given, verification fails if the controller of the signing key is not the expectedSigner.
 * @param input.allowUpgraded If `expectedSigner` is a light DID, setting this flag to `true` will accept signatures by the corresponding full DID.
 * @param input.expectedVerificationMethod Which relationship to the signer DID the key must have.
 * @param input.didResolveKey Allows specifying a custom DID key resolve. Defaults to the built-in [[resolveKey]].
 */
async function verifyDidSignature({ message, signature, keyUri, expectedSigner, allowUpgraded = false, expectedVerificationMethod, didResolveKey = index_js_1.resolveKey, }) {
    // checks if key uri points to the right did; alternatively we could check the key's controller
    const signer = (0, Did_utils_js_1.parse)(keyUri);
    if (expectedSigner && expectedSigner !== signer.did) {
        // check for allowable exceptions
        const expected = (0, Did_utils_js_1.parse)(expectedSigner);
        // NECESSARY CONDITION: subjects and versions match
        const subjectVersionMatch = expected.address === signer.address && expected.version === signer.version;
        // EITHER: signer is a full did and we allow signatures by corresponding full did
        const allowedUpgrade = allowUpgraded && signer.type === 'full';
        // OR: both are light dids and their auth key type matches
        const keyTypeMatch = signer.type === 'light' &&
            expected.type === 'light' &&
            expected.authKeyTypeEncoding === signer.authKeyTypeEncoding;
        if (!(subjectVersionMatch && (allowedUpgrade || keyTypeMatch))) {
            throw new utils_1.SDKErrors.DidSubjectMismatchError(signer.did, expected.did);
        }
    }
    const { publicKey } = await didResolveKey(keyUri, expectedVerificationMethod);
    utils_1.Crypto.verify(message, signature, publicKey);
}
exports.verifyDidSignature = verifyDidSignature;
/**
 * Type guard assuring that the input is a valid DidSignature object, consisting of a signature as hex and the uri of the signing key.
 * Does not cryptographically verify the signature itself!
 *
 * @param input Arbitrary input.
 * @returns True if validation of form has passed.
 */
function isDidSignature(input) {
    try {
        verifyDidSignatureDataStructure(input);
        return true;
    }
    catch (cause) {
        return false;
    }
}
exports.isDidSignature = isDidSignature;
/**
 * Transforms the output of a [[SignCallback]] into the [[DidSignature]] format suitable for json-based data exchange.
 *
 * @param input Signature data returned from the [[SignCallback]].
 * @param input.signature Signature bytes.
 * @param input.keyUri DID URI of the key used for signing.
 * @returns A [[DidSignature]] object where signature is hex-encoded.
 */
function signatureToJson({ signature, keyUri, }) {
    return { signature: utils_1.Crypto.u8aToHex(signature), keyUri };
}
exports.signatureToJson = signatureToJson;
/**
 * Deserializes a [[DidSignature]] for signature verification.
 * Handles backwards compatibility to an older version of the interface where the `keyUri` property was called `keyId`.
 *
 * @param input A [[DidSignature]] object.
 * @returns The deserialized DidSignature where the signature is represented as a Uint8Array.
 */
function signatureFromJson(input) {
    const keyUri = 'keyUri' in input ? input.keyUri : input.keyId;
    const signature = utils_1.Crypto.coToUInt8(input.signature);
    return { signature, keyUri };
}
exports.signatureFromJson = signatureFromJson;
