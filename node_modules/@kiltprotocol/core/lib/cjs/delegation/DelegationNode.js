"use strict";
/**
 * Copyright (c) 2018-2022, BOTLabs GmbH.
 *
 * This source code is licensed under the BSD 4-Clause "Original" license
 * found in the LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DelegationNode = void 0;
const tslib_1 = require("tslib");
const utils_1 = require("@kiltprotocol/utils");
const config_1 = require("@kiltprotocol/config");
const Did = tslib_1.__importStar(require("@kiltprotocol/did"));
const Attestation_chain_js_1 = require("../attestation/Attestation.chain.js");
const DelegationNode_chain_js_1 = require("./DelegationNode.chain.js");
const DelegationHierarchyDetails_chain_js_1 = require("./DelegationHierarchyDetails.chain.js");
const DelegationNodeUtils = tslib_1.__importStar(require("./DelegationNode.utils.js"));
const log = config_1.ConfigService.LoggingFactory.getLogger('DelegationNode');
/**
 * Delegation nodes are used within the KILT protocol to construct the trust hierarchy.
 *
 * Starting from the root node, entities can delegate the right to issue attestations to Claimers for a certain CTYPE and also delegate the right to attest and to delegate further nodes.
 *
 * A delegation object is stored on-chain, and can be revoked.
 *
 * A delegation can and may restrict permissions.
 *
 * Permissions:
 *   * Delegate.
 *   * Attest.
 */
class DelegationNode {
    id;
    hierarchyId;
    parentId;
    childrenIdentifiers = [];
    account;
    permissions;
    hierarchyDetails;
    revoked;
    // eslint-disable-next-line jsdoc/require-param
    /**
     * Creates a new [DelegationNode] from an [IDelegationNode].
     *
     */
    constructor({ id, hierarchyId, parentId, childrenIds, account, permissions, revoked, }) {
        this.id = id;
        this.hierarchyId = hierarchyId;
        this.parentId = parentId;
        this.childrenIdentifiers = childrenIds;
        this.account = account;
        this.permissions = permissions;
        this.revoked = revoked;
        DelegationNodeUtils.errorCheck(this);
    }
    get childrenIds() {
        return this.childrenIdentifiers;
    }
    /**
     * Builds a new [DelegationNode] representing a regular delegation node ready to be submitted to the chain for creation.
     *
     * @param input - An partial [IDelegationNode] input object.
     * @param input.hierarchyId - The delegation hierarchy under which to store the node.
     * @param input.parentId - The parent node under which to store the node.
     * @param input.account - The owner (i.e., delegate) of this delegation.
     * @param input.permissions - The set of permissions associated with this delegation node.
     * @returns A new [DelegationNode] with a randomly generated id.
     */
    static newNode({ hierarchyId, parentId, // Cannot be undefined here
    account, permissions, }) {
        return new DelegationNode({
            id: utils_1.UUID.generate(),
            hierarchyId,
            parentId,
            account,
            permissions,
            childrenIds: [],
            revoked: false,
        });
    }
    /**
     * Builds a new [DelegationNode] representing a root delegation node ready to be submitted to the chain for creation.
     *
     * @param input - An input object.
     * @param input.account - The address of this delegation (and of the whole hierarchy under it).
     * @param input.permissions - The set of permissions associated with this delegation node.
     * @param input.cTypeHash - The cTypeHash associated with the entire hierarchy.
     * @returns A new [DelegationNode] with a randomly generated id.
     */
    static newRoot({ account, permissions, cTypeHash, }) {
        const nodeId = utils_1.UUID.generate();
        const newNode = new DelegationNode({
            id: nodeId,
            hierarchyId: nodeId,
            account,
            permissions,
            childrenIds: [],
            revoked: false,
        });
        newNode.hierarchyDetails = {
            id: nodeId,
            cTypeHash,
        };
        return newNode;
    }
    /**
     * Lazily fetches the details of the hierarchy the node is part of and return its CType.
     *
     * @returns The CType hash associated with the delegation hierarchy.
     */
    async getCTypeHash() {
        const { cTypeHash } = await this.getHierarchyDetails();
        return cTypeHash;
    }
    /**
     * Fetches the details of the hierarchy this delegation node belongs to.
     *
     * @returns Promise containing the [[IDelegationHierarchyDetails]] of this delegation node.
     */
    async getHierarchyDetails() {
        if (!this.hierarchyDetails) {
            this.hierarchyDetails = await (0, DelegationHierarchyDetails_chain_js_1.fetch)(this.hierarchyId);
        }
        return this.hierarchyDetails;
    }
    /**
     * Fetches the parent node of this delegation node.
     *
     * @returns Promise containing the parent as [[DelegationNode]] or [null].
     */
    async getParent() {
        try {
            if (!this.parentId)
                return null;
            return (0, DelegationNode_chain_js_1.fetch)(this.parentId);
        }
        catch {
            return null;
        }
    }
    /**
     * Fetches the children nodes of this delegation node.
     *
     * @returns Promise containing the children as an array of [[DelegationNode]], which is empty if there are no children.
     */
    async getChildren() {
        try {
            // Updates the children info with the latest information available on chain.
            this.childrenIdentifiers = (await (0, DelegationNode_chain_js_1.fetch)(this.id)).childrenIds;
        }
        catch {
            // ignore missing
        }
        return (0, DelegationNode_chain_js_1.getChildren)(this);
    }
    /**
     * Fetches and resolves all attestations attested with this delegation node.
     *
     * @returns Promise containing all resolved attestations attested with this node.
     */
    async getAttestations() {
        const attestationHashes = await this.getAttestationHashes();
        const api = config_1.ConfigService.get('api');
        const attestations = await Promise.all(attestationHashes.map(async (claimHash) => {
            const encoded = await api.query.attestation.attestations(claimHash);
            if (encoded.isNone)
                return undefined;
            return (0, Attestation_chain_js_1.fromChain)(encoded, claimHash);
        }));
        return attestations.filter((value) => !!value);
    }
    /**
     * Fetches all hashes of attestations attested with this delegation node.
     *
     * @returns Promise containing all attestation hashes attested with this node.
     */
    async getAttestationHashes() {
        return (0, DelegationNode_chain_js_1.getAttestationHashes)(this.id);
    }
    /**
     *
     * Generates the delegation hash from the delegations' property values.
     *
     * This hash is signed by the delegate and later stored along with the delegation to
     * make sure delegation data (such as permissions) has not been tampered with.
     *
     * @returns The hash representation of this delegation **as a byte array**.
     */
    generateHash() {
        const propsToHash = [this.id, this.hierarchyId];
        if (this.parentId) {
            propsToHash.push(this.parentId);
        }
        const uint8Props = propsToHash.map((value) => utils_1.Crypto.coToUInt8(value));
        uint8Props.push(DelegationNodeUtils.permissionsAsBitset(this));
        const generated = utils_1.Crypto.hash(utils_1.Crypto.u8aConcat(...uint8Props), 256);
        log.debug(`generateHash(): ${utils_1.Crypto.u8aToHex(generated)}`);
        return generated;
    }
    /**
     * Signs the delegation hash from the delegations' property values.
     *
     * This is required to anchor the delegation node on chain in order to enforce the delegate's consent.
     *
     * @param delegateDid The DID of the delegate.
     * @param sign The callback to sign the delegation creation details for the delegate.
     * @returns The DID signature over the delegation **as a hex string**.
     */
    async delegateSign(delegateDid, sign) {
        const delegateSignature = await sign({
            data: this.generateHash(),
            did: delegateDid.uri,
            keyRelationship: 'authentication',
        });
        const { fragment } = Did.parse(delegateSignature.keyUri);
        if (!fragment) {
            throw new utils_1.SDKErrors.DidError(`DID key uri "${delegateSignature.keyUri}" couldn't be parsed`);
        }
        const key = Did.getKey(delegateDid, fragment);
        if (!key) {
            throw new utils_1.SDKErrors.DidError(`Key with fragment "${fragment}" was not found on DID: "${delegateDid.uri}"`);
        }
        return Did.didSignatureToChain(key, delegateSignature.signature);
    }
    /**
     * Synchronise the delegation node state with the latest state as stored on the blockchain.
     *
     * @returns An updated instance of the same [DelegationNode] containing the up-to-date state fetched from the chain.
     */
    async getLatestState() {
        return (0, DelegationNode_chain_js_1.fetch)(this.id);
    }
    /**
     * Stores the delegation node on chain.
     *
     * @param signature Signature of the delegate to ensure it is done under the delegate's permission.
     * @returns Promise containing an unsigned SubmittableExtrinsic.
     */
    async getStoreTx(signature) {
        const api = config_1.ConfigService.get('api');
        if (this.isRoot()) {
            return api.tx.delegation.createHierarchy(this.hierarchyId, await this.getCTypeHash());
        }
        if (!signature) {
            throw new utils_1.SDKErrors.DelegateSignatureMissingError();
        }
        return api.tx.delegation.addDelegation(...(0, DelegationNode_chain_js_1.addDelegationToChainArgs)(this, signature));
    }
    isRoot() {
        return this.id === this.hierarchyId && !this.parentId;
    }
    /**
     * Verifies the delegation node by fetching it from chain and checking its revocation status.
     */
    async verify() {
        const node = await (0, DelegationNode_chain_js_1.fetch)(this.id);
        if (node.revoked !== false) {
            throw new utils_1.SDKErrors.InvalidDelegationNodeError('Delegation node revoked');
        }
    }
    /**
     * Checks on chain whether an identity with the given DID is delegating to the current node.
     *
     * @param did The DID to search for.
     *
     * @returns An object containing a `node` owned by the identity if it is delegating, plus the number of `steps` traversed. `steps` is 0 if the DID is owner of the current node.
     */
    async findAncestorOwnedBy(did) {
        if (this.account === did) {
            return {
                steps: 0,
                node: this,
            };
        }
        if (!this.parentId) {
            return {
                steps: 0,
                node: null,
            };
        }
        try {
            const parent = await (0, DelegationNode_chain_js_1.fetch)(this.parentId);
            const result = await parent.findAncestorOwnedBy(did);
            result.steps += 1;
            return result;
        }
        catch {
            return {
                steps: 0,
                node: null,
            };
        }
    }
    /**
     * Recursively counts all nodes that descend from the current node (excluding the current node). It is important to first refresh the state of the node from the chain.
     *
     * @returns Promise resolving to the node count.
     */
    async subtreeNodeCount() {
        const children = await this.getChildren();
        if (children.length === 0) {
            return 0;
        }
        const childrensChildCounts = await Promise.all(children.map((child) => child.subtreeNodeCount()));
        return (children.length +
            childrensChildCounts.reduce((previous, current) => previous + current));
    }
    /**
     * Revokes the delegation node on chain.
     *
     * @param did The address of the identity used to revoke the delegation.
     * @returns Promise containing an unsigned SubmittableExtrinsic.
     */
    async getRevokeTx(did) {
        const { steps, node } = await this.findAncestorOwnedBy(did);
        if (!node) {
            throw new utils_1.SDKErrors.UnauthorizedError(`The DID "${did}" is not among the delegators and may not revoke this node`);
        }
        const childCount = await this.subtreeNodeCount();
        log.debug(`:: revoke(${this.id}) with maxRevocations=${childCount} and maxDepth = ${steps} through delegation node ${node?.id} and identity ${did}`);
        const api = config_1.ConfigService.get('api');
        return api.tx.delegation.revokeDelegation(this.id, steps, childCount);
    }
    /**
     * Removes the delegation node from the chain.
     *
     * @returns Promise containing an unsigned SubmittableExtrinsic.
     */
    async getRemoveTx() {
        const childCount = await this.subtreeNodeCount();
        log.debug(`:: remove(${this.id}) with maxRevocations=${childCount}`);
        const api = config_1.ConfigService.get('api');
        return api.tx.delegation.removeDelegation(this.id, childCount);
    }
    /**
     * Reclaims the deposit of a delegation and removes the delegation and all its children.
     *
     * This call can only be successfully executed if the submitter of the transaction is the original payer of the delegation deposit.
     *
     * @returns A promise containing the unsigned SubmittableExtrinsic (submittable transaction).
     */
    async getReclaimDepositTx() {
        const childCount = await this.subtreeNodeCount();
        log.debug(`:: getReclaimDepositTx(${this.id}) with maxRemovals=${childCount}`);
        const api = config_1.ConfigService.get('api');
        return api.tx.delegation.reclaimDeposit(this.id, childCount);
    }
    /**
     * Queries the delegation node with its [delegationId].
     *
     * @param delegationId The unique identifier of the desired delegation.
     * @returns Promise containing the [[DelegationNode]].
     */
    static async fetch(delegationId) {
        log.info(`:: fetch('${delegationId}')`);
        const result = await (0, DelegationNode_chain_js_1.fetch)(delegationId);
        log.info(`result: ${JSON.stringify(result)}`);
        return result;
    }
}
exports.DelegationNode = DelegationNode;
