/**
 * Copyright (c) 2018-2022, BOTLabs GmbH.
 *
 * This source code is licensed under the BSD 4-Clause "Original" license
 * found in the LICENSE file in the root directory of this source tree.
 */
import type { DidDocument, DidServiceEndpoint, DidUri, NewDidEncryptionKey, NewLightDidVerificationKey } from '@kiltprotocol/types';
/**
 * The options that can be used to create a light DID.
 */
export declare type CreateDocumentInput = {
    /**
     * The DID authentication key. This is mandatory and will be used as the first authentication key
     * of the full DID upon migration.
     */
    authentication: [NewLightDidVerificationKey];
    /**
     * The optional DID encryption key. If present, it will be used as the first key agreement key
     * of the full DID upon migration.
     */
    keyAgreement?: [NewDidEncryptionKey];
    /**
     * The set of service endpoints associated with this DID. Each service endpoint ID must be unique.
     * The service ID must not contain the DID prefix when used to create a new DID.
     */
    service?: DidServiceEndpoint[];
};
/**
 * Create [[DidDocument]] of a light DID using the provided keys and endpoints.
 * Sets proper key IDs, builds light DID URI.
 * Private keys are assumed to already live in another storage, as it contains reference only to public keys.
 *
 * @param input The input.
 * @param input.authentication The array containing light DID authentication key.
 * @param input.keyAgreement The optional array containing light DID encryption key.
 * @param input.service The optional light DID service endpoints.
 *
 * @returns The resulting [[DidDocument]].
 */
export declare function createLightDidDocument({ authentication, keyAgreement, service, }: CreateDocumentInput): DidDocument;
/**
 * Create [[DidDocument]] of a light DID by parsing the provided input URI.
 * Only use for DIDs you control, when you are certain they have not been upgraded to on-chain full DIDs.
 * For the DIDs you have received from external sources use [[resolve]] etc.
 *
 * Parsing is possible because of the self-describing and self-containing nature of light DIDs.
 * Private keys are assumed to already live in another storage, as it contains reference only to public keys.
 *
 * @param uri The DID URI to parse.
 * @param failIfFragmentPresent Whether to fail when parsing the URI in case a fragment is present or not, which is not relevant to the creation of the DID. It defaults to true.
 *
 * @returns The resulting [[DidDocument]].
 */
export declare function parseDocumentFromLightDid(uri: DidUri, failIfFragmentPresent?: boolean): DidDocument;
