"use strict";
/**
 * Copyright (c) 2018-2022, BOTLabs GmbH.
 *
 * This source code is licensed under the BSD 4-Clause "Original" license
 * found in the LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveService = exports.resolveKey = exports.resolvedKeyToKey = exports.keyToResolvedKey = exports.resolve = void 0;
const tslib_1 = require("tslib");
const utils_1 = require("@kiltprotocol/utils");
const config_1 = require("@kiltprotocol/config");
const Did = tslib_1.__importStar(require("../index.js"));
const Did_chain_js_1 = require("../Did.chain.js");
const Did_rpc_js_1 = require("../Did.rpc.js");
const Did_utils_js_1 = require("../Did.utils.js");
/**
 * Resolve a DID URI to the DID document and its metadata.
 *
 * The URI can also identify a key or a service, but it will be ignored during resolution.
 *
 * @param did The subject's DID.
 * @returns The details associated with the DID subject.
 */
async function resolve(did) {
    const { type } = (0, Did_utils_js_1.parse)(did);
    const api = config_1.ConfigService.get('api');
    const queryFunction = api.call.did?.query ?? api.call.didApi.queryDid;
    const { section, version } = queryFunction?.meta ?? {};
    if (version > 2)
        throw new Error(`This version of the KILT sdk supports runtime api '${section}' <=v2 , but the blockchain runtime implements ${version}. Please upgrade!`);
    let document;
    try {
        const encodedLinkedInfo = await queryFunction((0, Did_chain_js_1.toChain)(did));
        document = (0, Did_rpc_js_1.linkedInfoFromChain)(encodedLinkedInfo).document;
    }
    catch {
        // ignore errors
    }
    if (type === 'full' && document) {
        return {
            document,
            metadata: {
                deactivated: false,
            },
        };
    }
    // If the full DID has been deleted (or the light DID was upgraded and deleted),
    // return the info in the resolution metadata.
    const isFullDidDeleted = (await api.query.did.didBlacklist((0, Did_chain_js_1.toChain)(did)))
        .isSome;
    if (isFullDidDeleted) {
        return {
            // No canonicalId and no details are returned as we consider this DID deactivated/deleted.
            metadata: {
                deactivated: true,
            },
        };
    }
    if (type === 'full') {
        return null;
    }
    const lightDocument = Did.parseDocumentFromLightDid(did, false);
    // If a full DID with same subject is present, return the resolution metadata accordingly.
    if (document) {
        return {
            metadata: {
                canonicalId: (0, Did_utils_js_1.getFullDidUri)(did),
                deactivated: false,
            },
        };
    }
    // If no full DID details nor deletion info is found, the light DID is un-migrated.
    // Metadata will simply contain `deactivated: false`.
    return {
        document: lightDocument,
        metadata: {
            deactivated: false,
        },
    };
}
exports.resolve = resolve;
/**
 * Converts the DID key in the format returned by `resolveKey()`, useful for own implementations of `resolveKey`.
 *
 * @param key The DID key in the SDK format.
 * @param did The DID the key belongs to.
 * @returns The key in the resolveKey-format.
 */
function keyToResolvedKey(key, did) {
    const { id, publicKey, includedAt, type } = key;
    return {
        controller: did,
        id: `${did}${id}`,
        publicKey,
        type,
        ...(includedAt && { includedAt }),
    };
}
exports.keyToResolvedKey = keyToResolvedKey;
/**
 * Converts the DID key returned by the `resolveKey()` into the format used in the SDK.
 *
 * @param key The key in the resolveKey-format.
 * @returns The key in the SDK format.
 */
function resolvedKeyToKey(key) {
    const { id, publicKey, includedAt, type } = key;
    return {
        id: Did.parse(id).fragment,
        publicKey,
        type,
        ...(includedAt && { includedAt }),
    };
}
exports.resolvedKeyToKey = resolvedKeyToKey;
/**
 * Resolve a DID key URI to the key details.
 *
 * @param keyUri The DID key URI.
 * @param expectedVerificationMethod Optional key relationship the key has to belong to.
 * @returns The details associated with the key.
 */
async function resolveKey(keyUri, expectedVerificationMethod) {
    const { did, fragment: keyId } = (0, Did_utils_js_1.parse)(keyUri);
    // A fragment (keyId) IS expected to resolve a key.
    if (!keyId) {
        throw new utils_1.SDKErrors.DidError(`Key URI "${keyUri}" is not a valid DID resource`);
    }
    const resolved = await resolve(did);
    if (!resolved) {
        throw new utils_1.SDKErrors.DidNotFoundError();
    }
    const { document, metadata: { canonicalId }, } = resolved;
    // If the light DID has been upgraded we consider the old key URI invalid, the full DID URI should be used instead.
    if (canonicalId) {
        throw new utils_1.SDKErrors.DidResolveUpgradedDidError();
    }
    if (!document) {
        throw new utils_1.SDKErrors.DidDeactivatedError();
    }
    const key = Did.getKey(document, keyId);
    if (!key) {
        throw new utils_1.SDKErrors.DidNotFoundError('Key not found in DID');
    }
    // Check whether the provided key ID is within the keys for a given verification relationship, if provided.
    if (expectedVerificationMethod &&
        !document[expectedVerificationMethod]?.some(({ id }) => keyId === id)) {
        throw new utils_1.SDKErrors.DidError(`No key "${keyUri}" for the verification method "${expectedVerificationMethod}"`);
    }
    return keyToResolvedKey(key, did);
}
exports.resolveKey = resolveKey;
/**
 * Resolve a DID service URI to the service details.
 *
 * @param serviceUri The DID service URI.
 * @returns The details associated with the service endpoint.
 */
async function resolveService(serviceUri) {
    const { did, fragment: serviceId } = (0, Did_utils_js_1.parse)(serviceUri);
    // A fragment (serviceId) IS expected to resolve a key.
    if (!serviceId) {
        throw new utils_1.SDKErrors.DidError(`Service URI "${serviceUri}" is not a valid DID resource`);
    }
    const resolved = await resolve(did);
    if (!resolved) {
        throw new utils_1.SDKErrors.DidNotFoundError();
    }
    const { document, metadata: { canonicalId }, } = resolved;
    // If the light DID has been upgraded we consider the old service URI invalid, the full DID URI should be used instead.
    if (canonicalId) {
        throw new utils_1.SDKErrors.DidResolveUpgradedDidError();
    }
    if (!document) {
        throw new utils_1.SDKErrors.DidDeactivatedError();
    }
    const service = Did.getService(document, serviceId);
    if (!service) {
        throw new utils_1.SDKErrors.DidNotFoundError('Service not found in DID');
    }
    return {
        ...service,
        id: `${did}${serviceId}`,
    };
}
exports.resolveService = resolveService;
