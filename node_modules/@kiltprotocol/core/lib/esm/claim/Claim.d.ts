/**
 * Copyright (c) 2018-2022, BOTLabs GmbH.
 *
 * This source code is licensed under the BSD 4-Clause "Original" license
 * found in the LICENSE file in the root directory of this source tree.
 */
import type { HexString } from '@polkadot/util/types';
import type { DidUri, IClaim, ICType, PartialClaim } from '@kiltprotocol/types';
import { Crypto } from '@kiltprotocol/utils';
/**
 * Produces JSON-LD readable representations of KILT claims. This is done by implicitly or explicitly transforming property keys to globally unique predicates.
 * Where possible these predicates are taken directly from the Verifiable Credentials vocabulary. Properties that are unique to a [[CType]] are transformed into predicates by prepending the [[CType]][schema][$id].
 *
 * @param claim A (partial) [[IClaim]] from to build a JSON-LD representation from. The `cTypeHash` property is required.
 * @param expanded Return an expanded instead of a compacted representation. While property transformation is done explicitly in the expanded format, it is otherwise done implicitly via adding JSON-LD's reserved `@context` properties while leaving [[IClaim]][contents] property keys untouched.
 * @returns An object which can be serialized into valid JSON-LD representing an [[IClaim]].
 */
export declare function toJsonLD(claim: PartialClaim, expanded?: boolean): Record<string, unknown>;
/**
 * Produces salted hashes of individual statements comprising a (partial) [[IClaim]] to enable selective disclosure of contents. Can also be used to reproduce hashes for the purpose of validation.
 *
 * @param claim Full or partial [[IClaim]] to produce statement hashes from.
 * @param options Object containing optional parameters.
 * @param options.canonicalisation Canonicalisation routine that produces an array of statement strings from the [IClaim]. Default produces individual `{"key":"value"}` JSON representations where keys are transformed to expanded JSON-LD.
 * @param options.nonces Optional map of nonces as produced by this function.
 * @param options.nonceGenerator Nonce generator as defined by [[hashStatements]] to be used if no `nonces` are given. Default produces random UUIDs (v4).
 * @param options.hasher The hasher to be used. Required but defaults to 256 bit blake2 over `${nonce}${statement}`.
 * @returns An array of salted `hashes` and a `nonceMap` where keys correspond to unsalted statement hashes.
 */
export declare function hashClaimContents(claim: PartialClaim, options?: Crypto.HashingOptions & {
    canonicalisation?: (claim: PartialClaim) => string[];
}): {
    hashes: HexString[];
    nonceMap: Record<string, string>;
};
/**
 * Used to verify the hash list based proof over the set of disclosed attributes in a [[Claim]].
 *
 * @param claim Full or partial [[IClaim]] to verify proof against.
 * @param proof Proof consisting of a map that matches nonces to statement digests and the resulting hashes.
 * @param proof.nonces A map where a statement digest as produces by options.hasher is mapped to a nonce.
 * @param proof.hashes Array containing hashes which are signed into the credential. Should result from feeding statement digests and nonces in proof.nonce to options.hasher.
 * @param options Object containing optional parameters.
 * @param options.canonicalisation Canonicalisation routine that produces an array of statement strings from the [IClaim]. Default produces individual `{"key":"value"}` JSON representations where keys are transformed to expanded JSON-LD.
 * @param options.hasher The hasher to be used. Required but defaults to 256 bit blake2 over `${nonce}${statement}`.
 */
export declare function verifyDisclosedAttributes(claim: PartialClaim, proof: {
    nonces: Record<string, string>;
    hashes: string[];
}, options?: Pick<Crypto.HashingOptions, 'hasher'> & {
    canonicalisation?: (claim: PartialClaim) => string[];
}): void;
/**
 * Checks whether the input meets all the required criteria of an [[IClaim]] object.
 * Throws on invalid input.
 *
 * @param input The potentially only partial IClaim.
 */
export declare function verifyDataStructure(input: IClaim | PartialClaim): void;
/**
 * Verifies the data structure and schema of a Claim.
 *
 * @param claimInput IClaim to verify.
 * @param cType ICType to verify claimInput's contents.
 */
export declare function verify(claimInput: IClaim, cType: ICType): void;
/**
 * Builds a [[Claim]] from a [[CType]] which has nested [[CType]]s within the schema.
 *
 * @param cTypeInput A [[CType]] object that has nested [[CType]]s.
 * @param nestedCType The array of [[CType]]s, which are used inside the main [[CType]].
 * @param claimContents The data inside the [[Claim]].
 * @param claimOwner The DID of the owner of the [[Claim]].
 *
 * @returns A [[Claim]] the owner can use.
 */
export declare function fromNestedCTypeClaim(cTypeInput: ICType, nestedCType: ICType[], claimContents: IClaim['contents'], claimOwner: DidUri): IClaim;
/**
 * Constructs a new Claim from the given [[ICType]], IClaim['contents'] and [[DidUri]].
 *
 * @param cType [[ICType]] for which the Claim will be built.
 * @param claimContents IClaim['contents'] to be used as the pure contents of the instantiated Claim.
 * @param claimOwner The DID to be used as the Claim owner.
 * @returns A Claim object.
 */
export declare function fromCTypeAndClaimContents(cType: ICType, claimContents: IClaim['contents'], claimOwner: DidUri): IClaim;
/**
 * Custom Type Guard to determine input being of type IClaim.
 *
 * @param input The potentially only partial IClaim.
 *
 * @returns Boolean whether input is of type IClaim.
 */
export declare function isIClaim(input: unknown): input is IClaim;
