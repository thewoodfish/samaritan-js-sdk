/**
 * Copyright (c) 2018-2022, BOTLabs GmbH.
 *
 * This source code is licensed under the BSD 4-Clause "Original" license
 * found in the LICENSE file in the root directory of this source tree.
 */
/// <reference types="bn.js" />
import type { Option } from '@polkadot/types';
import type { AccountId32, Extrinsic } from '@polkadot/types/interfaces';
import type { AnyNumber } from '@polkadot/types/types';
import { BN } from '@polkadot/util';
import type { Deposit, DidDocument, DidServiceEndpoint, DidUri, DidVerificationKey, KiltAddress, NewDidEncryptionKey, NewDidVerificationKey, SignExtrinsicCallback, SignRequestData, SignResponseData, SubmittableExtrinsic, UriFragment, VerificationKeyRelationship } from '@kiltprotocol/types';
import type { DidDidDetails, DidDidDetailsDidPublicKey, DidDidDetailsDidPublicKeyDetails, DidServiceEndpointsDidEndpoint, KiltSupportDeposit } from '@kiltprotocol/augment-api';
import { EncodedEncryptionKey, EncodedSignature, EncodedVerificationKey } from './Did.utils.js';
export declare type ChainDidPublicKey = DidDidDetailsDidPublicKey;
export declare type ChainDidPublicKeyDetails = DidDidDetailsDidPublicKeyDetails;
/**
 * Format a DID to be used as a parameter for the blockchain API functions.

 * @param did The DID to format.
 * @returns The blockchain-formatted DID.
 */
export declare function toChain(did: DidUri): KiltAddress;
/**
 * Format a DID resource ID to be used as a parameter for the blockchain API functions.

 * @param id The DID resource ID to format.
 * @returns The blockchain-formatted ID.
 */
export declare function resourceIdToChain(id: UriFragment): string;
/**
 * Convert the deposit data coming from the blockchain to JS object.
 *
 * @param deposit The blockchain-formatted deposit data.
 * @returns The deposit data.
 */
export declare function depositFromChain(deposit: KiltSupportDeposit): Deposit;
declare type ChainDocument = Pick<DidDocument, 'authentication' | 'assertionMethod' | 'capabilityDelegation' | 'keyAgreement'> & {
    lastTxCounter: BN;
    deposit: Deposit;
};
/**
 * Convert the DID data from blockchain format to the DID URI.
 *
 * @param encoded The chain-formatted DID.
 * @returns The DID URI.
 */
export declare function fromChain(encoded: AccountId32): DidUri;
/**
 * Convert the DID Document data from the blockchain format to a JS object.
 *
 * @param encoded The chain-formatted DID Document.
 * @returns The DID Document.
 */
export declare function documentFromChain(encoded: Option<DidDidDetails>): ChainDocument;
interface ChainEndpoint {
    id: string;
    serviceTypes: DidServiceEndpoint['type'];
    urls: DidServiceEndpoint['serviceEndpoint'];
}
/**
 * Performs sanity checks on service endpoint data, making sure that the following conditions are met:
 *   - The `id` property is a string containing a valid URI fragment according to RFC#3986, not a complete DID URI.
 *   - If the `uris` property contains one or more strings, they must be valid URIs according to RFC#3986.
 *
 * @param endpoint A service endpoint object to check.
 */
export declare function validateService(endpoint: DidServiceEndpoint): void;
/**
 * Format the DID service to be used as a parameter for the blockchain API functions.
 *
 * @param service The DID service to format.
 * @returns The blockchain-formatted DID service.
 */
export declare function serviceToChain(service: DidServiceEndpoint): ChainEndpoint;
/**
 * Convert the DID service data coming from the blockchain to JS object.
 *
 * @param encoded The blockchain-formatted DID service data.
 * @returns The DID service.
 */
export declare function serviceFromChain(encoded: Option<DidServiceEndpointsDidEndpoint>): DidServiceEndpoint;
export declare type AuthorizeCallInput = {
    did: DidUri;
    txCounter: AnyNumber;
    call: Extrinsic;
    submitter: KiltAddress;
    blockNumber?: AnyNumber;
};
export declare function publicKeyToChain(key: NewDidVerificationKey): EncodedVerificationKey;
export declare function publicKeyToChain(key: NewDidEncryptionKey): EncodedEncryptionKey;
interface GetStoreTxInput {
    authentication: [NewDidVerificationKey];
    assertionMethod?: [NewDidVerificationKey];
    capabilityDelegation?: [NewDidVerificationKey];
    keyAgreement?: NewDidEncryptionKey[];
    service?: DidServiceEndpoint[];
}
export declare type GetStoreTxSignCallback = (signData: Omit<SignRequestData, 'did'>) => Promise<Omit<SignResponseData, 'keyUri'>>;
/**
 * Create a DID creation operation which includes the information provided.
 *
 * The resulting extrinsic can be submitted to create an on-chain DID that has the provided keys and service endpoints.
 *
 * A DID creation operation can contain at most 25 new service endpoints.
 * Additionally, each service endpoint must respect the following conditions:
 * - The service endpoint ID is at most 50 bytes long and is a valid URI fragment according to RFC#3986.
 * - The service endpoint has at most 1 service type, with a value that is at most 50 bytes long.
 * - The service endpoint has at most 1 URI, with a value that is at most 200 bytes long, and which is a valid URI according to RFC#3986.
 *
 * @param input The DID keys and services to store, also accepts DidDocument, so you can store a light DID for example.
 * @param submitter The KILT address authorized to submit the creation operation.
 * @param sign The sign callback. The authentication key has to be used.
 *
 * @returns The SubmittableExtrinsic for the DID creation operation.
 */
export declare function getStoreTx(input: GetStoreTxInput | DidDocument, submitter: KiltAddress, sign: GetStoreTxSignCallback): Promise<SubmittableExtrinsic>;
export interface SigningOptions {
    sign: SignExtrinsicCallback;
    keyRelationship: VerificationKeyRelationship;
}
/**
 * DID related operations on the KILT blockchain require authorization by a full DID. This is realized by requiring that relevant extrinsics are signed with a key featured by a full DID as a verification method.
 * Such extrinsics can be produced using this function.
 *
 * @param params Object wrapping all input to the function.
 * @param params.did Full DID.
 * @param params.keyRelationship DID key relationship to be used for authorization.
 * @param params.sign The callback to interface with the key store managing the private key to be used.
 * @param params.call The call or extrinsic to be authorized.
 * @param params.txCounter The nonce or txCounter value for this extrinsic, which must be on larger than the current txCounter value of the authorizing full DID.
 * @param params.submitter Payment account allowed to submit this extrinsic and cover its fees, which will end up owning any deposit associated with newly created records.
 * @param params.blockNumber Block number for determining the validity period of this authorization. If omitted, the current block number will be fetched from chain.
 * @returns A DID authorized extrinsic that, after signing with the payment account mentioned in the params, is ready for submission.
 */
export declare function generateDidAuthenticatedTx({ did, keyRelationship, sign, call, txCounter, submitter, blockNumber, }: AuthorizeCallInput & SigningOptions): Promise<SubmittableExtrinsic>;
/**
 * Compiles an enum-type key-value pair representation of a signature created with a full DID verification method. Required for creating full DID signed extrinsics.
 *
 * @param key Object describing data associated with a public key.
 * @param signature Object containing a signature generated with a full DID associated public key.
 * @returns Data restructured to allow SCALE encoding by polkadot api.
 */
export declare function didSignatureToChain(key: DidVerificationKey, signature: Uint8Array): EncodedSignature;
export {};
