"use strict";
/**
 * Copyright (c) 2018-2022, BOTLabs GmbH.
 *
 * This source code is licensed under the BSD 4-Clause "Original" license
 * found in the LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyAgainstCredential = exports.isIAttestation = exports.getDelegationDetails = exports.fromCredentialAndDid = exports.verifyDataStructure = void 0;
const tslib_1 = require("tslib");
const utils_1 = require("@kiltprotocol/utils");
const Did = tslib_1.__importStar(require("@kiltprotocol/did"));
const DelegationNode_js_1 = require("../delegation/DelegationNode.js");
const Credential = tslib_1.__importStar(require("../credential/index.js"));
/**
 * An [[Attestation]] certifies a [[Claim]], sent by a claimer in the form of a [[Credential]]. [[Attestation]]s are **written on the blockchain** and are **revocable**.
 *
 * An [[Attestation]] can be queried from the chain. It's stored on-chain in a map:
 * * the key is the hash of the corresponding claim;
 * * the value is a tuple ([[CType]] hash, account, id of the Delegation, and revoked flag).
 *
 * @packageDocumentation
 */
/**
 * Checks whether the input meets all the required criteria of an [[IAttestation]] object.
 * Throws on invalid input.
 *
 * @param input The potentially only partial [[IAttestation]].
 */
function verifyDataStructure(input) {
    if (!input.cTypeHash) {
        throw new utils_1.SDKErrors.CTypeHashMissingError();
    }
    utils_1.DataUtils.verifyIsHex(input.cTypeHash, 256);
    if (!input.claimHash) {
        throw new utils_1.SDKErrors.ClaimHashMissingError();
    }
    utils_1.DataUtils.verifyIsHex(input.claimHash, 256);
    if (typeof input.delegationId !== 'string' && input.delegationId !== null) {
        throw new utils_1.SDKErrors.DelegationIdTypeError();
    }
    if (!input.owner) {
        throw new utils_1.SDKErrors.OwnerMissingError();
    }
    Did.validateUri(input.owner, 'Did');
    if (typeof input.revoked !== 'boolean') {
        throw new utils_1.SDKErrors.RevokedTypeError();
    }
}
exports.verifyDataStructure = verifyDataStructure;
/**
 * Builds a new instance of an [[Attestation]], from a complete set of input required for an attestation.
 *
 * @param credential - The base credential for attestation.
 * @param attesterDid - The attester's DID, used to attest to the underlying claim.
 * @returns A new [[Attestation]] object.
 */
function fromCredentialAndDid(credential, attesterDid) {
    const attestation = {
        claimHash: credential.rootHash,
        cTypeHash: credential.claim.cTypeHash,
        delegationId: credential.delegationId,
        owner: attesterDid,
        revoked: false,
    };
    verifyDataStructure(attestation);
    return attestation;
}
exports.fromCredentialAndDid = fromCredentialAndDid;
/**
 * Tries to fetch the delegationId and if successful fetch the rootId.
 *
 * @param input - The ID of the Delegation stored in [[Attestation]] , or the whole Attestation object.
 * @returns A promise of the affiliated [[DelegationNode]].
 */
async function getDelegationDetails(input) {
    if (input === null) {
        throw new utils_1.SDKErrors.HierarchyQueryError('null');
    }
    let delegationId;
    if (typeof input === 'string') {
        delegationId = input;
    }
    else {
        delegationId = input.delegationId;
    }
    if (!delegationId) {
        throw new utils_1.SDKErrors.HierarchyQueryError('null');
    }
    const delegationNode = await DelegationNode_js_1.DelegationNode.fetch(delegationId);
    return delegationNode.getHierarchyDetails();
}
exports.getDelegationDetails = getDelegationDetails;
/**
 * Custom Type Guard to determine input being of type IAttestation.
 *
 * @param input The potentially only partial IAttestation.
 * @returns Boolean whether input is of type IAttestation.
 */
function isIAttestation(input) {
    try {
        verifyDataStructure(input);
    }
    catch (error) {
        return false;
    }
    return true;
}
exports.isIAttestation = isIAttestation;
/**
 * Verifies whether the data of the given attestation matches the one from the corresponding credential. It is valid if:
 * * the [[Credential]] object has valid data (see [[Credential.verifyDataIntegrity]]);
 * and
 * * the hash of the [[Credential]] object, and the hash of the [[Attestation]].
 *
 * @param attestation - The attestation to verify.
 * @param credential - The credential to verify against.
 */
function verifyAgainstCredential(attestation, credential) {
    if (credential.claim.cTypeHash !== attestation.cTypeHash ||
        credential.rootHash !== attestation.claimHash) {
        throw new utils_1.SDKErrors.CredentialUnverifiableError('Attestation does not match credential');
    }
    Credential.verifyDataIntegrity(credential);
}
exports.verifyAgainstCredential = verifyAgainstCredential;
