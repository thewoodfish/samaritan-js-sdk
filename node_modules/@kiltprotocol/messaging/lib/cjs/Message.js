"use strict";
/**
 * Copyright (c) 2018-2022, BOTLabs GmbH.
 *
 * This source code is licensed under the BSD 4-Clause "Original" license
 * found in the LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.encrypt = exports.fromBody = exports.verify = exports.decrypt = exports.ensureOwnerIsSender = exports.verifyRequiredCTypeProperties = exports.verifyMessageEnvelope = exports.verifyMessageBody = exports.verifyDelegationStructure = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@kiltprotocol/core");
const utils_1 = require("@kiltprotocol/utils");
const Did = tslib_1.__importStar(require("@kiltprotocol/did"));
const util_1 = require("@polkadot/util");
/**
 * Checks if delegation data is well formed.
 *
 * @param delegationData Delegation data to check.
 */
function verifyDelegationStructure(delegationData) {
    const { permissions, id, parentId, isPCR, account } = delegationData;
    if (!id) {
        throw new utils_1.SDKErrors.DelegationIdMissingError();
    }
    else if (typeof id !== 'string' || !(0, util_1.isHex)(id)) {
        throw new utils_1.SDKErrors.DelegationIdTypeError();
    }
    if (!account) {
        throw new utils_1.SDKErrors.OwnerMissingError();
    }
    Did.validateUri(account, 'Did');
    if (typeof isPCR !== 'boolean') {
        throw new TypeError('isPCR is expected to be a boolean');
    }
    if (permissions.length === 0 || permissions.length > 3) {
        throw new utils_1.SDKErrors.UnauthorizedError('Must have at least one permission and no more then two');
    }
    if (parentId && (typeof parentId !== 'string' || !(0, util_1.isHex)(parentId))) {
        throw new utils_1.SDKErrors.DelegationIdTypeError();
    }
}
exports.verifyDelegationStructure = verifyDelegationStructure;
/**
 * Checks if the message body is well-formed.
 *
 * @param body The message body.
 */
function verifyMessageBody(body) {
    switch (body.type) {
        case 'request-terms': {
            core_1.Claim.verifyDataStructure(body.content);
            break;
        }
        case 'submit-terms': {
            core_1.Claim.verifyDataStructure(body.content.claim);
            body.content.legitimations.forEach((credential) => core_1.Credential.verifyDataStructure(credential));
            if (body.content.delegationId) {
                utils_1.DataUtils.verifyIsHex(body.content.delegationId);
            }
            if (body.content.quote) {
                core_1.Quote.validateQuoteSchema(core_1.Quote.QuoteSchema, body.content.quote);
            }
            if (body.content.cTypes) {
                body.content.cTypes.forEach((val) => core_1.CType.verifyDataStructure(val));
            }
            break;
        }
        case 'reject-terms': {
            core_1.Claim.verifyDataStructure(body.content.claim);
            if (body.content.delegationId) {
                utils_1.DataUtils.verifyIsHex(body.content.delegationId);
            }
            body.content.legitimations.forEach((val) => core_1.Credential.verifyDataStructure(val));
            break;
        }
        case 'request-attestation': {
            core_1.Credential.verifyDataStructure(body.content.credential);
            if (body.content.quote) {
                core_1.Quote.validateQuoteSchema(core_1.Quote.QuoteSchema, body.content.quote);
            }
            break;
        }
        case 'submit-attestation': {
            core_1.Attestation.verifyDataStructure(body.content.attestation);
            break;
        }
        case 'reject-attestation': {
            if (!(0, util_1.isHex)(body.content)) {
                throw new utils_1.SDKErrors.HashMalformedError();
            }
            break;
        }
        case 'request-credential': {
            body.content.cTypes.forEach(({ cTypeHash, trustedAttesters, requiredProperties }) => {
                utils_1.DataUtils.verifyIsHex(cTypeHash);
                trustedAttesters?.forEach((did) => Did.validateUri(did, 'Did'));
                requiredProperties?.forEach((requiredProps) => {
                    if (typeof requiredProps !== 'string')
                        throw new TypeError('Required properties is expected to be a string');
                });
            });
            break;
        }
        case 'submit-credential': {
            body.content.forEach((presentation) => {
                core_1.Credential.verifyDataStructure(presentation);
                if (!Did.isDidSignature(presentation.claimerSignature)) {
                    throw new utils_1.SDKErrors.SignatureMalformedError();
                }
            });
            break;
        }
        case 'accept-credential': {
            body.content.forEach((cTypeHash) => utils_1.DataUtils.verifyIsHex(cTypeHash));
            break;
        }
        case 'reject-credential': {
            body.content.forEach((cTypeHash) => utils_1.DataUtils.verifyIsHex(cTypeHash));
            break;
        }
        case 'request-accept-delegation': {
            verifyDelegationStructure(body.content.delegationData);
            if (!Did.isDidSignature(body.content.signatures.inviter)) {
                throw new utils_1.SDKErrors.SignatureMalformedError();
            }
            if (!(0, util_1.isJsonObject)(body.content.metaData)) {
                throw new utils_1.SDKErrors.ObjectUnverifiableError();
            }
            break;
        }
        case 'submit-accept-delegation': {
            verifyDelegationStructure(body.content.delegationData);
            if (!Did.isDidSignature(body.content.signatures.inviter) ||
                !Did.isDidSignature(body.content.signatures.invitee)) {
                throw new utils_1.SDKErrors.SignatureMalformedError();
            }
            break;
        }
        case 'reject-accept-delegation': {
            verifyDelegationStructure(body.content);
            break;
        }
        case 'inform-create-delegation': {
            utils_1.DataUtils.verifyIsHex(body.content.delegationId);
            break;
        }
        default:
            throw new utils_1.SDKErrors.UnknownMessageBodyTypeError();
    }
}
exports.verifyMessageBody = verifyMessageBody;
/**
 * Checks if the message object is well-formed.
 *
 * @param message The message object.
 */
function verifyMessageEnvelope(message) {
    const { messageId, createdAt, receiver, sender, receivedAt, inReplyTo } = message;
    if (messageId !== undefined && typeof messageId !== 'string') {
        throw new TypeError('Message id is expected to be a string');
    }
    if (createdAt !== undefined && typeof createdAt !== 'number') {
        throw new TypeError('Created at is expected to be a number');
    }
    if (receivedAt !== undefined && typeof receivedAt !== 'number') {
        throw new TypeError('Received at is expected to be a number');
    }
    Did.validateUri(sender, 'Did');
    Did.validateUri(receiver, 'Did');
    if (inReplyTo && typeof inReplyTo !== 'string') {
        throw new TypeError('In reply to is expected to be a string');
    }
}
exports.verifyMessageEnvelope = verifyMessageEnvelope;
/**
 * Verifies required properties for a given [[CType]] before sending or receiving a message.
 *
 * @param requiredProperties The list of required properties that need to be verified against a [[CType]].
 * @param cType A [[CType]] used to verify the properties.
 */
function verifyRequiredCTypeProperties(requiredProperties, cType) {
    core_1.CType.verifyDataStructure(cType);
    const unknownProperties = requiredProperties.find((property) => !(property in cType.properties));
    if (unknownProperties) {
        throw new utils_1.SDKErrors.CTypeUnknownPropertiesError();
    }
}
exports.verifyRequiredCTypeProperties = verifyRequiredCTypeProperties;
/**
 * Verifies that the sender of a [[Message]] is also the owner of it, e.g the owner's and sender's DIDs refer to the same subject.
 *
 * @param message The [[Message]] object which needs to be decrypted.
 * @param message.body The body of the [[Message]] which depends on the [[BodyType]].
 * @param message.sender The sender's DID taken from the [[IMessage]].
 */
function ensureOwnerIsSender({ body, sender }) {
    switch (body.type) {
        case 'request-attestation':
            {
                const requestAttestation = body;
                if (!Did.isSameSubject(requestAttestation.content.credential.claim.owner, sender)) {
                    throw new utils_1.SDKErrors.IdentityMismatchError('Claim', 'Sender');
                }
            }
            break;
        case 'submit-attestation':
            {
                const submitAttestation = body;
                if (!Did.isSameSubject(submitAttestation.content.attestation.owner, sender)) {
                    throw new utils_1.SDKErrors.IdentityMismatchError('Attestation', 'Sender');
                }
            }
            break;
        case 'submit-credential':
            {
                const submitClaimsForCtype = body;
                submitClaimsForCtype.content.forEach((presentation) => {
                    if (!Did.isSameSubject(presentation.claim.owner, sender)) {
                        throw new utils_1.SDKErrors.IdentityMismatchError('Claims', 'Sender');
                    }
                });
            }
            break;
        default:
    }
}
exports.ensureOwnerIsSender = ensureOwnerIsSender;
/**
 * Symmetrically decrypts the result of [[encrypt]].
 *
 * @param encrypted The encrypted message.
 * @param decryptCallback The callback to decrypt with the secret key.
 * @param decryptionOptions Options to perform the decryption operation.
 * @param decryptionOptions.resolveKey The DID key resolver to use.
 * @returns The original [[Message]].
 */
async function decrypt(encrypted, decryptCallback, { resolveKey = Did.resolveKey, } = {}) {
    const { senderKeyUri, receiverKeyUri, ciphertext, nonce, receivedAt } = encrypted;
    const senderKeyDetails = await resolveKey(senderKeyUri, 'keyAgreement');
    const { fragment } = Did.parse(receiverKeyUri);
    if (!fragment) {
        throw new utils_1.SDKErrors.DidError(`No fragment for the receiver key ID "${receiverKeyUri}"`);
    }
    let data;
    try {
        data = (await decryptCallback({
            peerPublicKey: senderKeyDetails.publicKey,
            data: (0, util_1.hexToU8a)(ciphertext),
            nonce: (0, util_1.hexToU8a)(nonce),
            keyUri: receiverKeyUri,
        })).data;
    }
    catch (cause) {
        throw new utils_1.SDKErrors.DecodingMessageError(undefined, {
            cause: cause,
        });
    }
    const decoded = (0, util_1.u8aToString)(data);
    const { body, createdAt, messageId, inReplyTo, references, sender, receiver, } = JSON.parse(decoded);
    const decrypted = {
        receiver,
        sender,
        createdAt,
        body,
        messageId,
        receivedAt,
        inReplyTo,
        references,
    };
    if (sender !== senderKeyDetails.controller) {
        throw new utils_1.SDKErrors.IdentityMismatchError('Encryption key', 'Sender');
    }
    return decrypted;
}
exports.decrypt = decrypt;
/**
 * Checks the message structure and body contents (e.g. Hashes match, ensures the owner is the sender).
 * Throws, if a check fails.
 *
 * @param decryptedMessage The decrypted message to check.
 */
function verify(decryptedMessage) {
    verifyMessageBody(decryptedMessage.body);
    verifyMessageEnvelope(decryptedMessage);
    ensureOwnerIsSender(decryptedMessage);
}
exports.verify = verify;
/**
 * Constructs a message from a message body.
 * This should be encrypted with [[encrypt]] before sending to the receiver.
 *
 * @param body The body of the message.
 * @param sender The DID of the sender.
 * @param receiver The DID of the receiver.
 * @returns The message created.
 */
function fromBody(body, sender, receiver) {
    return {
        body,
        createdAt: Date.now(),
        receiver,
        sender,
        messageId: utils_1.UUID.generate(),
    };
}
exports.fromBody = fromBody;
/**
 * Encrypts the [[Message]] as a string. This can be reversed with [[decrypt]].
 *
 * @param message The message to encrypt.
 * @param encryptCallback The callback to encrypt with the secret key.
 * @param receiverKeyUri The key URI of the receiver.
 * @param encryptionOptions Options to perform the encryption operation.
 * @param encryptionOptions.resolveKey The DID key resolver to use.
 *
 * @returns The encrypted version of the original [[Message]], see [[IEncryptedMessage]].
 */
async function encrypt(message, encryptCallback, receiverKeyUri, { resolveKey = Did.resolveKey, } = {}) {
    const receiverKey = await resolveKey(receiverKeyUri, 'keyAgreement');
    if (message.receiver !== receiverKey.controller) {
        throw new utils_1.SDKErrors.IdentityMismatchError('receiver public key', 'receiver');
    }
    const toEncrypt = {
        body: message.body,
        createdAt: message.createdAt,
        sender: message.sender,
        receiver: message.receiver,
        messageId: message.messageId,
        inReplyTo: message.inReplyTo,
        references: message.references,
    };
    const serialized = (0, util_1.stringToU8a)(JSON.stringify(toEncrypt));
    const encrypted = await encryptCallback({
        did: message.sender,
        data: serialized,
        peerPublicKey: receiverKey.publicKey,
    });
    const ciphertext = (0, util_1.u8aToHex)(encrypted.data);
    const nonce = (0, util_1.u8aToHex)(encrypted.nonce);
    return {
        receivedAt: message.receivedAt,
        ciphertext,
        nonce,
        senderKeyUri: encrypted.keyUri,
        receiverKeyUri: receiverKey.id,
    };
}
exports.encrypt = encrypt;
