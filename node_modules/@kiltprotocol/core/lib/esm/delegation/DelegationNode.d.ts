/**
 * Copyright (c) 2018-2022, BOTLabs GmbH.
 *
 * This source code is licensed under the BSD 4-Clause "Original" license
 * found in the LICENSE file in the root directory of this source tree.
 */
import type { CTypeHash, DidDocument, DidUri, IAttestation, IDelegationHierarchyDetails, IDelegationNode, SignCallback, SubmittableExtrinsic } from '@kiltprotocol/types';
import * as Did from '@kiltprotocol/did';
import type { DelegationHierarchyDetailsRecord } from './DelegationDecoder';
declare type NewDelegationNodeInput = Required<Pick<IDelegationNode, 'hierarchyId' | 'parentId' | 'account' | 'permissions'>>;
declare type NewDelegationRootInput = Pick<IDelegationNode, 'account' | 'permissions'> & DelegationHierarchyDetailsRecord;
/**
 * Delegation nodes are used within the KILT protocol to construct the trust hierarchy.
 *
 * Starting from the root node, entities can delegate the right to issue attestations to Claimers for a certain CTYPE and also delegate the right to attest and to delegate further nodes.
 *
 * A delegation object is stored on-chain, and can be revoked.
 *
 * A delegation can and may restrict permissions.
 *
 * Permissions:
 *   * Delegate.
 *   * Attest.
 */
export declare class DelegationNode implements IDelegationNode {
    readonly id: IDelegationNode['id'];
    readonly hierarchyId: IDelegationNode['hierarchyId'];
    readonly parentId?: IDelegationNode['parentId'];
    private childrenIdentifiers;
    readonly account: DidUri;
    readonly permissions: IDelegationNode['permissions'];
    private hierarchyDetails?;
    readonly revoked: boolean;
    /**
     * Creates a new [DelegationNode] from an [IDelegationNode].
     *
     */
    constructor({ id, hierarchyId, parentId, childrenIds, account, permissions, revoked, }: IDelegationNode);
    get childrenIds(): Array<IDelegationNode['id']>;
    /**
     * Builds a new [DelegationNode] representing a regular delegation node ready to be submitted to the chain for creation.
     *
     * @param input - An partial [IDelegationNode] input object.
     * @param input.hierarchyId - The delegation hierarchy under which to store the node.
     * @param input.parentId - The parent node under which to store the node.
     * @param input.account - The owner (i.e., delegate) of this delegation.
     * @param input.permissions - The set of permissions associated with this delegation node.
     * @returns A new [DelegationNode] with a randomly generated id.
     */
    static newNode({ hierarchyId, parentId, // Cannot be undefined here
    account, permissions, }: NewDelegationNodeInput): DelegationNode;
    /**
     * Builds a new [DelegationNode] representing a root delegation node ready to be submitted to the chain for creation.
     *
     * @param input - An input object.
     * @param input.account - The address of this delegation (and of the whole hierarchy under it).
     * @param input.permissions - The set of permissions associated with this delegation node.
     * @param input.cTypeHash - The cTypeHash associated with the entire hierarchy.
     * @returns A new [DelegationNode] with a randomly generated id.
     */
    static newRoot({ account, permissions, cTypeHash, }: NewDelegationRootInput): DelegationNode;
    /**
     * Lazily fetches the details of the hierarchy the node is part of and return its CType.
     *
     * @returns The CType hash associated with the delegation hierarchy.
     */
    getCTypeHash(): Promise<CTypeHash>;
    /**
     * Fetches the details of the hierarchy this delegation node belongs to.
     *
     * @returns Promise containing the [[IDelegationHierarchyDetails]] of this delegation node.
     */
    getHierarchyDetails(): Promise<IDelegationHierarchyDetails>;
    /**
     * Fetches the parent node of this delegation node.
     *
     * @returns Promise containing the parent as [[DelegationNode]] or [null].
     */
    getParent(): Promise<DelegationNode | null>;
    /**
     * Fetches the children nodes of this delegation node.
     *
     * @returns Promise containing the children as an array of [[DelegationNode]], which is empty if there are no children.
     */
    getChildren(): Promise<DelegationNode[]>;
    /**
     * Fetches and resolves all attestations attested with this delegation node.
     *
     * @returns Promise containing all resolved attestations attested with this node.
     */
    getAttestations(): Promise<IAttestation[]>;
    /**
     * Fetches all hashes of attestations attested with this delegation node.
     *
     * @returns Promise containing all attestation hashes attested with this node.
     */
    getAttestationHashes(): Promise<Array<IAttestation['claimHash']>>;
    /**
     *
     * Generates the delegation hash from the delegations' property values.
     *
     * This hash is signed by the delegate and later stored along with the delegation to
     * make sure delegation data (such as permissions) has not been tampered with.
     *
     * @returns The hash representation of this delegation **as a byte array**.
     */
    generateHash(): Uint8Array;
    /**
     * Signs the delegation hash from the delegations' property values.
     *
     * This is required to anchor the delegation node on chain in order to enforce the delegate's consent.
     *
     * @param delegateDid The DID of the delegate.
     * @param sign The callback to sign the delegation creation details for the delegate.
     * @returns The DID signature over the delegation **as a hex string**.
     */
    delegateSign(delegateDid: DidDocument, sign: SignCallback): Promise<Did.EncodedSignature>;
    /**
     * Synchronise the delegation node state with the latest state as stored on the blockchain.
     *
     * @returns An updated instance of the same [DelegationNode] containing the up-to-date state fetched from the chain.
     */
    getLatestState(): Promise<DelegationNode>;
    /**
     * Stores the delegation node on chain.
     *
     * @param signature Signature of the delegate to ensure it is done under the delegate's permission.
     * @returns Promise containing an unsigned SubmittableExtrinsic.
     */
    getStoreTx(signature?: Did.EncodedSignature): Promise<SubmittableExtrinsic>;
    isRoot(): boolean;
    /**
     * Verifies the delegation node by fetching it from chain and checking its revocation status.
     */
    verify(): Promise<void>;
    /**
     * Checks on chain whether an identity with the given DID is delegating to the current node.
     *
     * @param did The DID to search for.
     *
     * @returns An object containing a `node` owned by the identity if it is delegating, plus the number of `steps` traversed. `steps` is 0 if the DID is owner of the current node.
     */
    findAncestorOwnedBy(did: DidUri): Promise<{
        steps: number;
        node: DelegationNode | null;
    }>;
    /**
     * Recursively counts all nodes that descend from the current node (excluding the current node). It is important to first refresh the state of the node from the chain.
     *
     * @returns Promise resolving to the node count.
     */
    subtreeNodeCount(): Promise<number>;
    /**
     * Revokes the delegation node on chain.
     *
     * @param did The address of the identity used to revoke the delegation.
     * @returns Promise containing an unsigned SubmittableExtrinsic.
     */
    getRevokeTx(did: DidUri): Promise<SubmittableExtrinsic>;
    /**
     * Removes the delegation node from the chain.
     *
     * @returns Promise containing an unsigned SubmittableExtrinsic.
     */
    getRemoveTx(): Promise<SubmittableExtrinsic>;
    /**
     * Reclaims the deposit of a delegation and removes the delegation and all its children.
     *
     * This call can only be successfully executed if the submitter of the transaction is the original payer of the delegation deposit.
     *
     * @returns A promise containing the unsigned SubmittableExtrinsic (submittable transaction).
     */
    getReclaimDepositTx(): Promise<SubmittableExtrinsic>;
    /**
     * Queries the delegation node with its [delegationId].
     *
     * @param delegationId The unique identifier of the desired delegation.
     * @returns Promise containing the [[DelegationNode]].
     */
    static fetch(delegationId: IDelegationNode['id']): Promise<DelegationNode>;
}
export {};
