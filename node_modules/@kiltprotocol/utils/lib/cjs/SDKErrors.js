"use strict";
/**
 * Copyright (c) 2018-2022, BOTLabs GmbH.
 *
 * This source code is licensed under the BSD 4-Clause "Original" license
 * found in the LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.InvalidProofForStatementError = exports.TimeoutError = exports.DecodingMessageError = exports.RootHashUnverifiableError = exports.SubscriptionsNotSupportedError = exports.BlockchainApiMissingError = exports.IdentityMismatchError = exports.NestedClaimUnverifiableError = exports.ClaimUnverifiableError = exports.CredentialUnverifiableError = exports.SignatureUnverifiableError = exports.LegitimationsUnverifiableError = exports.AddressInvalidError = exports.InvalidDidFormatError = exports.HierarchyQueryError = exports.DidSubjectMismatchError = exports.SignatureMalformedError = exports.UnknownMessageBodyTypeError = exports.ClaimNonceMapMalformedError = exports.QuoteUnverifiableError = exports.ObjectUnverifiableError = exports.ClaimContentsMalformedError = exports.InvalidDelegationNodeError = exports.InvalidRootNodeError = exports.DelegateSignatureMissingError = exports.DelegationIdMissingError = exports.DelegationIdTypeError = exports.DataStructureError = exports.HashMalformedError = exports.HashTypeError = exports.AddressTypeError = exports.ClaimMissingError = exports.ClaimNonceMapMissingError = exports.LegitimationsMissingError = exports.OwnerMissingError = exports.RevokedTypeError = exports.ClaimHashMissingError = exports.DidDeactivatedError = exports.DidResolveUpgradedDidError = exports.DidNotFoundError = exports.DidBatchError = exports.DidExporterError = exports.DidError = exports.EncryptionError = exports.UnsupportedKeyError = exports.CTypeUnknownPropertiesError = exports.CTypeIdMismatchError = exports.CTypeHashMissingError = exports.UnauthorizedError = exports.SDKError = void 0;
exports.CodecMismatchError = exports.NoProofForStatementError = void 0;
/**
 * KILT-specific errors with descriptions.
 *
 * @packageDocumentation
 */
/* eslint-disable max-classes-per-file */
class SDKError extends Error {
    constructor(message, options) {
        super(message, options);
        // this line is the only reason for using SDKError
        this.name = this.constructor.name;
    }
}
exports.SDKError = SDKError;
class UnauthorizedError extends SDKError {
}
exports.UnauthorizedError = UnauthorizedError;
class CTypeHashMissingError extends SDKError {
}
exports.CTypeHashMissingError = CTypeHashMissingError;
class CTypeIdMismatchError extends SDKError {
    constructor(fromSchema, provided) {
        super(`Provided $id "${provided}" does not match schema $id "${fromSchema}"`);
    }
}
exports.CTypeIdMismatchError = CTypeIdMismatchError;
class CTypeUnknownPropertiesError extends SDKError {
}
exports.CTypeUnknownPropertiesError = CTypeUnknownPropertiesError;
class UnsupportedKeyError extends SDKError {
    constructor(keyType) {
        super(`The provided key type "${keyType}" is currently not supported`);
    }
}
exports.UnsupportedKeyError = UnsupportedKeyError;
class EncryptionError extends SDKError {
}
exports.EncryptionError = EncryptionError;
class DidError extends SDKError {
}
exports.DidError = DidError;
class DidExporterError extends SDKError {
}
exports.DidExporterError = DidExporterError;
class DidBatchError extends SDKError {
}
exports.DidBatchError = DidBatchError;
class DidNotFoundError extends SDKError {
}
exports.DidNotFoundError = DidNotFoundError;
class DidResolveUpgradedDidError extends SDKError {
}
exports.DidResolveUpgradedDidError = DidResolveUpgradedDidError;
class DidDeactivatedError extends SDKError {
}
exports.DidDeactivatedError = DidDeactivatedError;
class ClaimHashMissingError extends SDKError {
}
exports.ClaimHashMissingError = ClaimHashMissingError;
class RevokedTypeError extends SDKError {
}
exports.RevokedTypeError = RevokedTypeError;
class OwnerMissingError extends SDKError {
}
exports.OwnerMissingError = OwnerMissingError;
class LegitimationsMissingError extends SDKError {
}
exports.LegitimationsMissingError = LegitimationsMissingError;
class ClaimNonceMapMissingError extends SDKError {
}
exports.ClaimNonceMapMissingError = ClaimNonceMapMissingError;
class ClaimMissingError extends SDKError {
}
exports.ClaimMissingError = ClaimMissingError;
class AddressTypeError extends SDKError {
}
exports.AddressTypeError = AddressTypeError;
class HashTypeError extends SDKError {
}
exports.HashTypeError = HashTypeError;
class HashMalformedError extends SDKError {
    constructor(hash, type) {
        if (hash && type) {
            super(`Provided ${type} hash "${hash}" is invalid or malformed`);
        }
        else if (hash) {
            super(`Provided hash "${hash}" is invalid or malformed`);
        }
        else {
            super('Provided hash invalid or malformed');
        }
    }
}
exports.HashMalformedError = HashMalformedError;
class DataStructureError extends SDKError {
}
exports.DataStructureError = DataStructureError;
class DelegationIdTypeError extends SDKError {
}
exports.DelegationIdTypeError = DelegationIdTypeError;
class DelegationIdMissingError extends SDKError {
}
exports.DelegationIdMissingError = DelegationIdMissingError;
class DelegateSignatureMissingError extends SDKError {
}
exports.DelegateSignatureMissingError = DelegateSignatureMissingError;
class InvalidRootNodeError extends SDKError {
}
exports.InvalidRootNodeError = InvalidRootNodeError;
class InvalidDelegationNodeError extends SDKError {
}
exports.InvalidDelegationNodeError = InvalidDelegationNodeError;
class ClaimContentsMalformedError extends SDKError {
}
exports.ClaimContentsMalformedError = ClaimContentsMalformedError;
class ObjectUnverifiableError extends SDKError {
}
exports.ObjectUnverifiableError = ObjectUnverifiableError;
class QuoteUnverifiableError extends SDKError {
}
exports.QuoteUnverifiableError = QuoteUnverifiableError;
class ClaimNonceMapMalformedError extends SDKError {
    constructor(statement) {
        if (statement) {
            super(`Nonce map malformed or incomplete for statement "${statement}"`);
        }
        else {
            super(`Nonce map malformed or incomplete`);
        }
    }
}
exports.ClaimNonceMapMalformedError = ClaimNonceMapMalformedError;
class UnknownMessageBodyTypeError extends SDKError {
}
exports.UnknownMessageBodyTypeError = UnknownMessageBodyTypeError;
class SignatureMalformedError extends SDKError {
}
exports.SignatureMalformedError = SignatureMalformedError;
class DidSubjectMismatchError extends SDKError {
    constructor(actual, expected) {
        super(`The DID "${actual}" doesn't match the DID Document's URI "${expected}"`);
    }
}
exports.DidSubjectMismatchError = DidSubjectMismatchError;
class HierarchyQueryError extends SDKError {
    constructor(rootId) {
        super(`Could not find root node with id "${rootId}"`);
    }
}
exports.HierarchyQueryError = HierarchyQueryError;
class InvalidDidFormatError extends SDKError {
    constructor(did, options) {
        super(`Not a valid KILT DID "${did}"`, options);
    }
}
exports.InvalidDidFormatError = InvalidDidFormatError;
class AddressInvalidError extends SDKError {
    constructor(address, type) {
        if (address && type) {
            super(`Provided ${type} address "${address}" is invalid`);
        }
        else if (address) {
            super(`Provided address "${address}" is invalid`);
        }
        else {
            super(`Provided address invalid`);
        }
    }
}
exports.AddressInvalidError = AddressInvalidError;
class LegitimationsUnverifiableError extends SDKError {
}
exports.LegitimationsUnverifiableError = LegitimationsUnverifiableError;
class SignatureUnverifiableError extends SDKError {
}
exports.SignatureUnverifiableError = SignatureUnverifiableError;
class CredentialUnverifiableError extends SDKError {
}
exports.CredentialUnverifiableError = CredentialUnverifiableError;
class ClaimUnverifiableError extends SDKError {
}
exports.ClaimUnverifiableError = ClaimUnverifiableError;
class NestedClaimUnverifiableError extends SDKError {
}
exports.NestedClaimUnverifiableError = NestedClaimUnverifiableError;
class IdentityMismatchError extends SDKError {
    constructor(context, type) {
        if (type && context) {
            super(`${type} is not owner of the ${context}`);
        }
        else if (context) {
            super(`Identity is not owner of the ${context}`);
        }
        else {
            super('Addresses expected to be equal mismatched');
        }
    }
}
exports.IdentityMismatchError = IdentityMismatchError;
class BlockchainApiMissingError extends SDKError {
    constructor(options) {
        super('The blockchain API is not set. Did you forget to call `Kilt.connect(…)` or `Kilt.init(…)`?', options);
    }
}
exports.BlockchainApiMissingError = BlockchainApiMissingError;
class SubscriptionsNotSupportedError extends SDKError {
    constructor(options) {
        super('This function is not available if the blockchain API does not support state or event subscriptions, use `WsProvider` to enable the complete feature set', options);
    }
}
exports.SubscriptionsNotSupportedError = SubscriptionsNotSupportedError;
class RootHashUnverifiableError extends SDKError {
}
exports.RootHashUnverifiableError = RootHashUnverifiableError;
class DecodingMessageError extends SDKError {
}
exports.DecodingMessageError = DecodingMessageError;
class TimeoutError extends SDKError {
}
exports.TimeoutError = TimeoutError;
class InvalidProofForStatementError extends SDKError {
    constructor(statement) {
        super(`Proof could not be verified for statement:\n${statement}`);
    }
}
exports.InvalidProofForStatementError = InvalidProofForStatementError;
class NoProofForStatementError extends SDKError {
    constructor(statement) {
        super(`No matching proof found for statement:\n${statement}`);
    }
}
exports.NoProofForStatementError = NoProofForStatementError;
class CodecMismatchError extends SDKError {
}
exports.CodecMismatchError = CodecMismatchError;
