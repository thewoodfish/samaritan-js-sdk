/**
 * Copyright (c) 2018-2022, BOTLabs GmbH.
 *
 * This source code is licensed under the BSD 4-Clause "Original" license
 * found in the LICENSE file in the root directory of this source tree.
 */
import { decode as cborDecode, encode as cborEncode } from 'cbor';
import { base58Decode, base58Encode, decodeAddress, } from '@polkadot/util-crypto';
import { encryptionKeyTypes } from '@kiltprotocol/types';
import { SDKErrors, ss58Format } from '@kiltprotocol/utils';
import { getAddressByKey, parse } from '../Did.utils.js';
import { resourceIdToChain, validateService } from '../Did.chain.js';
const authenticationKeyId = '#authentication';
const encryptionKeyId = '#encryption';
const verificationKeyTypeToLightDidEncoding = {
    sr25519: '00',
    ed25519: '01',
};
const lightDidEncodingToVerificationKeyType = {
    '00': 'sr25519',
    '01': 'ed25519',
};
function validateCreateDocumentInput({ authentication, keyAgreement, service: services, }) {
    // Check authentication key type
    const authenticationKeyTypeEncoding = verificationKeyTypeToLightDidEncoding[authentication[0].type];
    if (!authenticationKeyTypeEncoding) {
        throw new SDKErrors.UnsupportedKeyError(authentication[0].type);
    }
    if (keyAgreement?.[0].type &&
        !encryptionKeyTypes.includes(keyAgreement[0].type)) {
        throw new SDKErrors.DidError(`Encryption key type "${keyAgreement[0].type}" is not supported`);
    }
    // Checks that for all service IDs have regular strings as their ID and not a full DID.
    // Plus, we forbid a service ID to be `authentication` or `encryption` as that would create confusion
    // when upgrading to a full DID.
    services?.forEach((service) => {
        // A service ID cannot have a reserved ID that is used for key IDs.
        if (service.id === '#authentication' || service.id === '#encryption') {
            throw new SDKErrors.DidError(`Cannot specify a service ID with the name "${service.id}" as it is a reserved keyword`);
        }
        validateService(service);
    });
}
const KEY_AGREEMENT_MAP_KEY = 'e';
const SERVICES_MAP_KEY = 's';
/**
 * Serialize the optional encryption key and service endpoints of an off-chain DID using the CBOR serialization algorithm
 * and encoding the result in Base58 format with a multibase prefix.
 *
 * @param details The light DID details to encode.
 * @param details.keyAgreement The DID encryption key.
 * @param details.service The DID service endpoints.
 * @returns The Base58-encoded and CBOR-serialized off-chain DID optional details.
 */
function serializeAdditionalLightDidDetails({ keyAgreement, service, }) {
    const objectToSerialize = {};
    if (keyAgreement) {
        const key = keyAgreement[0];
        objectToSerialize[KEY_AGREEMENT_MAP_KEY] = key;
    }
    if (service && service.length > 0) {
        objectToSerialize[SERVICES_MAP_KEY] = service.map(({ id, ...rest }) => ({
            id: resourceIdToChain(id),
            ...rest,
        }));
    }
    if (Object.keys(objectToSerialize).length === 0) {
        return undefined;
    }
    const serializationVersion = 0x0;
    const serialized = cborEncode(objectToSerialize);
    return base58Encode([serializationVersion, ...serialized], true);
}
function deserializeAdditionalLightDidDetails(rawInput, version = 1) {
    if (version !== 1) {
        throw new SDKErrors.DidError('Serialization version not supported');
    }
    const decoded = base58Decode(rawInput, true);
    const serializationVersion = decoded[0];
    const serialized = decoded.slice(1);
    if (serializationVersion !== 0x0) {
        throw new SDKErrors.DidError('Serialization algorithm not supported');
    }
    const deserialized = cborDecode(serialized);
    const keyAgreement = deserialized[KEY_AGREEMENT_MAP_KEY];
    return {
        keyAgreement: keyAgreement && [keyAgreement],
        service: deserialized[SERVICES_MAP_KEY]?.map(({ id, ...rest }) => ({
            id: `#${id}`,
            ...rest,
        })),
    };
}
/**
 * Create [[DidDocument]] of a light DID using the provided keys and endpoints.
 * Sets proper key IDs, builds light DID URI.
 * Private keys are assumed to already live in another storage, as it contains reference only to public keys.
 *
 * @param input The input.
 * @param input.authentication The array containing light DID authentication key.
 * @param input.keyAgreement The optional array containing light DID encryption key.
 * @param input.service The optional light DID service endpoints.
 *
 * @returns The resulting [[DidDocument]].
 */
export function createLightDidDocument({ authentication, keyAgreement = undefined, service, }) {
    validateCreateDocumentInput({
        authentication,
        keyAgreement,
        service,
    });
    const encodedDetails = serializeAdditionalLightDidDetails({
        keyAgreement,
        service,
    });
    // Validity is checked in validateCreateDocumentInput
    const authenticationKeyTypeEncoding = verificationKeyTypeToLightDidEncoding[authentication[0].type];
    const address = getAddressByKey(authentication[0]);
    const encodedDetailsString = encodedDetails ? `:${encodedDetails}` : '';
    const uri = `did:kilt:light:${authenticationKeyTypeEncoding}${address}${encodedDetailsString}`;
    const did = {
        uri,
        authentication: [
            {
                id: authenticationKeyId,
                type: authentication[0].type,
                publicKey: authentication[0].publicKey,
            },
        ],
        service,
    };
    if (keyAgreement !== undefined) {
        did.keyAgreement = [
            {
                id: encryptionKeyId,
                type: keyAgreement[0].type,
                publicKey: keyAgreement[0].publicKey,
            },
        ];
    }
    return did;
}
/**
 * Create [[DidDocument]] of a light DID by parsing the provided input URI.
 * Only use for DIDs you control, when you are certain they have not been upgraded to on-chain full DIDs.
 * For the DIDs you have received from external sources use [[resolve]] etc.
 *
 * Parsing is possible because of the self-describing and self-containing nature of light DIDs.
 * Private keys are assumed to already live in another storage, as it contains reference only to public keys.
 *
 * @param uri The DID URI to parse.
 * @param failIfFragmentPresent Whether to fail when parsing the URI in case a fragment is present or not, which is not relevant to the creation of the DID. It defaults to true.
 *
 * @returns The resulting [[DidDocument]].
 */
export function parseDocumentFromLightDid(uri, failIfFragmentPresent = true) {
    const { address, version, encodedDetails, fragment, type, authKeyTypeEncoding, } = parse(uri);
    if (type !== 'light') {
        throw new SDKErrors.DidError(`Cannot build a light DID from the provided URI "${uri}" because it does not refer to a light DID`);
    }
    if (fragment && failIfFragmentPresent) {
        throw new SDKErrors.DidError(`Cannot build a light DID from the provided URI "${uri}" because it has a fragment`);
    }
    const keyType = authKeyTypeEncoding &&
        lightDidEncodingToVerificationKeyType[authKeyTypeEncoding];
    if (keyType === undefined) {
        throw new SDKErrors.DidError(`Authentication key encoding "${authKeyTypeEncoding}" does not match any supported key type`);
    }
    const publicKey = decodeAddress(address, false, ss58Format);
    const authentication = [
        { publicKey, type: keyType },
    ];
    if (!encodedDetails) {
        return createLightDidDocument({ authentication });
    }
    const { keyAgreement, service } = deserializeAdditionalLightDidDetails(encodedDetails, version);
    return createLightDidDocument({
        authentication,
        keyAgreement,
        service,
    });
}
